#! /usr/bin/env perl

use Error qw(:try);
use Error::Simple;
use Getopt::Long qw(:config no_ignore_case); #Parse options
use LWP::UserAgent; #Send requests and receive responses
use sigtrap qw/handler signal_handler INT TERM/; #Catch SIGINT and SIGTERM
use Term::ReadLine; #Use a REPL for querying

use strict;

my $usage = "Debug Log Querying Client Options:

Required:

Optional:
    --log,-l    <path>      Enables logging of all received output.

    --help                  Display this message.

Example Usage:

    perl logquery --log output.log

";

my $query_usage = "Query structure: <action> <address>[:port] [target] [parser] [interpreter]

Supported Actions: ALIAS, BACKUP, DELETE, EXIT, GET, LIST, PARSE, PARSEALL, PUT, QUERY, QUIT

";

my %OPT;
try {
    GetOptions(
        "log=s" => \$OPT{log},
        "help|?" => sub { print $usage; exit(0); },
    );
}
catch Error::Simple with {
    my $E = shift;
    print STDERR $E->{-text};
    die "Failed to parse command line options.\n";
};

my $client = 0;
my $err = 0;
my $log = $OPT{log};
if($err) {
    print(STDERR "Could not find $err required arguments.\n");
    print_help();
}

my %aliases = ();
my %files = ();
my %hosts = ();
my $prompt = "Enter Query > ";
my $term = Term::ReadLine->new("logquery");
$client = LWP::UserAgent->new(
    protocols_allowed => ["http", "https"],
    timeout => 60
);
$client->env_proxy;
print(STDOUT $query_usage);
while(defined(my $input = $term->readline($prompt))) {
    opendir(DIR, ".");
    my @localfiles = grep(/log-deposit.*.out$/,readdir(DIR));
    closedir(DIR);
    foreach my $file (@localfiles) {
        if(exists $files{$file}) { next; }
        $files{$file} = 1;
        get_info($file);
    }
    $term->add_history($input) if /\S/;
    if(uc($input) eq "QUIT" or uc($input) eq "EXIT") {
        print(STDERR "Exit message received. Cleaning up and shutting down.\n");
        exit(0);
    }
    my @parts = split(' ', $input);
    my $action = uc($parts[0]);
    my $destination = $parts[1];
    my $target = $parts[2];
    my $parser = $parts[3];
    my $interpreter = $parts[4];
    my $result = "";
    if(exists($aliases{$destination})) { $destination = $aliases{$destination}; }
    if($action eq "QUERY") {
        my $index = 3;
        while($index < scalar(@parts)) {
            $target = $target . " " . $parts[$index];
            $index++;
        }
    }
    if($action and !$destination) {
        print(STDERR "Incorrect query syntax used. Missing field(s).\n\n");
        print(STDOUT $query_usage);
    }
    elsif($action eq "EXIT" or $action eq "QUIT" or $action eq "LIST") { $result = request($action, $destination); }
    elsif($action eq "ALIAS") {
        $aliases{$target} = $destination;
        print(STDOUT "Please use '$target' to access '$destination' host.\n");
    }
    elsif($action eq "BACKUP" or $action eq "DELETE" or $action eq "GET" or $action or
        $action eq "PARSE" or $action eq "PUT" or $action eq "QUERY" or $action eq "PARSEALL") {
        if(!$target) {
            print(STDERR "Incorrect query syntax used. Missing field(s).\n\n");
            print(STDOUT $query_usage);
            next;
        }
        if(($action eq "PARSE" or $action eq "PARSEALL") and !$parser) {
            print(STDERR "No parser specified. Aborting request.\n\n");
            print(STDOUT $query_usage);
            next;
        }
        elsif(($action eq "PUT") and !(-e $target)) {
            print(STDERR "File '$target' not found locally. Aborting request.\n\n");
            print(STDOUT $query_usage);
            next;
        }

        if($action eq "PARSE" or $action eq "PARSEALL") { $result = request($action, $destination, $target, $parser, $interpreter); }
        else { $result = request($action, $destination, $target); }
    }
    else {
        print(STDERR "Unknown action '$action' specified.\n\n");
        print(STDOUT $query_usage);
    }
    chomp($result);
    if($log) {
        open(LOG, ">>", $log);
        print(LOG "$result\n");
        close(LOG);
    } 
    print(STDOUT "$result\n");
}

exit(0);

sub get_info {
    my ($file) = @_;
    open(FILE, $file);
    while(my $line = <FILE>) {
        if($line =~ m/To query log '(?<file>\S+)' with types '(?<types>\S+)' from system '(?<app>\S+)' use ID '(?<hash>\S+)' and query '(?<host>\S+)' to find out more./) {
            my $file = $+{file};
            my $types = $+{types};
            my $app = $+{app};
            my $hash = $+{hash};
            my $host = $+{host};
            if(exists $hosts{$host}) {
                my %newapps = ();
                my %newtypes = ();
                my @a1 = split(',', $hosts{$host}{apps});
                my @apps = (@a1, $app);
                my @t1 = split(',', $hosts{$host}{types});
                my @t2 = split(',', $types);
                my @types = (@t1, @t2);
                foreach my $a (@apps) { $newapps{$a} = 1; }
                foreach my $t (@types) { $newtypes{$t} = 1; }
                my $appstring = "";
                my $typestring = "";
                foreach my $a (keys(%newapps)) { $appstring = $appstring . $a . ","; }
                foreach my $t (keys(%newtypes)) { $typestring = $typestring . $t . ","; }
                chop($appstring);
                chop($typestring);
                $hosts{$host}{apps} = $appstring;
                $hosts{$host}{types} = $typestring;
                $hosts{$host}{files} = $hosts{$host}{files} . "," . $file;
                $hosts{$host}{hashes} = $hosts{$host}{hashes} . "," . $hash;
                next;
            }
            $hosts{$host}{apps} = $app;
            $hosts{$host}{files} = $file;
            $hosts{$host}{hashes} = $hash;
            $hosts{$host}{types} = $types;
        }
    }
    close(FILE);
    return 0;
}

sub request {
    my ($action, $destination, $target, $parser, $interpreter) = @_;
    my $content = 0;
    my $http = "http://" . $destination;
    my $response = 0;
    if($action eq "GET") { $http = $http . "/files?file=" . $target; }
    elsif($action eq "PARSEALL") {
        $http = $http . "/parse?parser=" . $parser;
        if($interpreter) { $http = $http . "&interpreter=" . $interpreter; }
        $content = $target;
    }
    elsif($action eq "PARSE") {
        $http = $http . "/parse?file=" . $target . "&parser=" . $parser;
        if($interpreter) { $http = $http . "&interpreter=" . $interpreter; }
    }
    elsif($target and ($action eq "PUT")) {
        $http = $http . "/parsers?file=" . $target;
        open(FILE, $target);
        while(my $line = <FILE>) { $content = $content . $line; } 
        close(FILE);
    }
    elsif($action eq "QUERY") {
        $http = $http . "/query";
        $content = $target;
    }
    elsif($action eq "BACKUP") { $http = $http . "/backup?file=" . $target; }
    elsif($action eq "DELETE") { $http = $http . "/delete?file=" . $target; }
    elsif($action eq "QUIT" or $action eq "EXIT") { $http = $http . "/exit"; }
    elsif($action eq "LIST") { $http = $http . "/listfiles"; }

    if($action eq "BACKUP" or $action eq "GET" or $action eq "PARSE" or $action eq "QUIT" or $action eq "EXIT" or $action eq "LIST") { $response = $client->get($http); }
    elsif($action eq "PUT" or $action eq "QUERY" or $action eq "PARSEALL") { $response = $client->put($http, "Content-Type" => "text/plain", Content => $content); }
    elsif($action eq "DELETE") { $response = $client->delete($http); }
    else { return "Request type '$action' not supported."; }
    if($response->is_success) { return $response->decoded_content; }
    else { return $response->status_line; }
}

sub signal_handler {
    print(STDERR "\nCaught '$!' signal. Terminating process.\n");
    exit(1);
}

sub print_help {
    print(STDOUT $usage);
    exit(1);
}

# vim: tabstop=8 shiftwidth=4 softtabstop=4 expandtab shiftround autoindent
