#! /usr/bin/env perl

use Data::Dumper;
use Error qw(:try);
use Error::Simple;
use Getopt::Long qw(:config no_ignore_case); #Parse options
use JSON;
use LWP::UserAgent; #Send requests and receive responses
use sigtrap qw/handler signal_handler INT TERM/; #Catch SIGINT and SIGTERM
use Term::ReadLine; #Use a REPL for querying
use URI::Encode;

use strict;

my $usage = "Debug Log Querying Client Options:

Required:

Optional:
    --log,-l    <path>      Enables logging of all sent requests and received output.

    --session,-s            Enables logging of user input history for next session.

    --help                  Display this message.

Example Usage:

    perl cli-client --log output.log

";

my $query_usage = "Query structure: <action> [URI] [options]

Where <action> is one of: ALIAS, EXIT, LIST, PRINT, QUERY, QUIT, SEND, SET, UNSET

And [options] is one of:
  ALIAS <URI> <STRING>
  PRINT <VARIABLE>
  QUERY <URI/ALIAS> <JSON>
  SET <VARIABLE> <VALUE>
  UNSET <VARIABLE>
";

my %OPT;
try {
    GetOptions(
        "log=s" => \$OPT{log},
        "session|?" => \$OPT{session},
        "help|?" => sub { print $usage; exit(0); },
    );
}
catch Error::Simple with {
    my $E = shift;
    print STDERR $E->{-text};
    die "Failed to parse command line options.\n";
};

my $client = 0;
my $debug = 0;
my $err = 0;
my $jx = "";
my $server = "";
my $log = $OPT{log};
my $session = $OPT{session};
if($err) {
    print(STDERR "Could not find $err required arguments.\n");
    print_help();
}

my %aliases = ();
my %components = ();
my %variables = ();
my $prompt = " \$ ";
my $term = Term::ReadLine->new("tlq");
$client = LWP::UserAgent->new(
    protocols_allowed => ["http", "https"],
    timeout => 10
);
$client->env_proxy;
if($session) {
    open(HISTORY, ">>", "cli-session") or die "Could not open session log for writing.\n";
    open(READHIST, "cli-session");
    while(my $line = <READHIST>) {
        chomp($line);
        $term->add_history($line);
    }
    close(READHIST);
}
print(STDOUT $query_usage);
while(defined(my $input = $term->readline($prompt))) {
    get_info("deposit-log");
    my @parts = split(' ', $input);
    my $action = uc($parts[0]);
    my $destination = $parts[1];
    my $target = $parts[2];
    my $result = "";
    if($debug) {
        if($action eq "SEND") {
            $prompt = " \$ ";
            $debug = 0;
            print(STDOUT "$jx\n");
            if(exists($aliases{$server})) { $server = $aliases{$server}; }
            $result = URI::Encode->new( { encode_reserved => 0 } )->decode(request("QUERY", $server, query_to_json($target)));
            print_result($target, $result);
            next;
        }
        $jx = $jx . $input;
        next;
    }
    $term->add_history($input) if /\S/;
    if($session) { print(HISTORY "$input\n"); }
    if(uc($input) eq "QUIT" or uc($input) eq "EXIT") { exit(0); } 
    if($action ne "LIST" and !$destination) { print_query_help(); }
    elsif($action eq "QUERY") {
        if(!$destination) {
            print_query_help();
            next;
        }
        $server = $destination;
        $debug = 1;
        $jx = "";
        $prompt = " > ";
        next; 
    }
    elsif($action eq "ALIAS") {
        $aliases{$target} = $destination;
        print(STDOUT "Please use alias $target to access $destination.\n");
    }
    elsif($action eq "PRINT") {
        if(exists $variables{$destination}) {
            print(STDOUT "$destination = $variables{$destination}\n");
        }
    }
    elsif($action eq "SET") {
        if($target eq "VALUE") { print(STDERR "Cannot overwrite magic variable VALUE.\n"); }
        else {
            $variables{$destination} = $target;
        }
    }
    elsif($action eq "UNSET") { delete($variables{$target}); }
    elsif($action eq "EXIT" or $action eq "QUIT") { $result = request($action, $destination); }
    elsif($action eq "LIST") { $result = list_components(); }
    else { print_query_help(); } 
    if($action ne "QUERY") { print_result($input, $result); }
}

if($session) { close(HISTORY); }
exit(0);

sub get_info {
    my ($file) = @_;
    open(FILE, $file);
    while(my $line = <FILE>) {
        if($line =~ m/^Component (?<uuid>\S+) created log\(s\) \[(?<logs>.*)\] with command (?<command>.+) queryable at (?<uri>\S+) and has parent (?<puuid>\S+).$/) {
            my $uuid = $+{uuid};
            my $puuid = $+{puuid};
            my $logs = $+{logs};
            my $command = $+{command};
            my $uri = $+{uri};
            my $host = "";
            if(!exists $components{$uri}) {
                if($uri =~ m/(?<host>https?:\/\/\S+\/).+/) { $host = $+{host}; }
                $components{$uri} = {};
                $components{$uri}{uuid} = $uuid;
                $components{$uri}{parent} = $puuid;
                $components{$uri}{logs} = $logs;
                $components{$uri}{command} = $command;
                $components{$uri}{uri} = $uri;
                $components{$uri}{host} = $host;
            }
        }
    }
    close(FILE);
    return 0;
}

sub list_components {
    my $return = "";
    foreach my $c (keys(%components)) {
        my $dump = Dumper($components{$c});
        $return = $return . "$c =>\n" . $dump . "\n";
    }
    return $return;
}

sub print_result {
    my ($input, $result) = @_;
    chomp($result);
    if($log) {
        open(LOG, ">>", $log) or die "Could not open $log for log writing.\n";
        print(LOG "$input =>\n$result\n");
        close(LOG);
    } 
}

sub query_to_json {
    my ($query) = @_;
    my %object;
    $object{query} = $query;
    my $json = JSON->new->encode(\%object);
    $json = URI::Encode->new( { encode_reserved => 0 } )->encode($json);
    return $json;
}

sub request {
    my ($action, $destination, $target) = @_;
    my $content = 0;
    my $http = $destination;
    my $response = 0;
    if($action eq "QUERY") {
        $content = $target;
        $response = $client->put($http, "Content-Type" => "text/plain", Content => $content);
    }
    elsif($action eq "QUIT" or $action eq "EXIT") {
        $http = $components{$destination}{host} . "/exit";
        $response = $client->get($http);
    }
    else { return "Request type $action not supported."; }
    if($response->is_success) { return $response->decoded_content; }
    else { return $response->status_line; }
}

sub signal_handler {
    print(STDERR "\nCaught '$!' signal. Terminating process.\n");
    exit(1);
}

sub print_help {
    print(STDERR $usage);
    exit(1);
}

sub print_query_help {
    print(STDERR "Incorrect query syntax used. Missing field(s).\n\n");
    print(STDERR $query_usage);
}

# vim: tabstop=8 shiftwidth=4 softtabstop=4 expandtab shiftround autoindent
