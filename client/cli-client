#! /usr/bin/env perl

use Data::Dumper;
use Error qw(:try);
use Error::Simple;
use Getopt::Long qw(:config no_ignore_case);
use JSON;
use LWP::UserAgent;
use sigtrap qw/handler signal_handler INT TERM/;
use Sys::Hostname;
use Term::ReadLine;
use Time::HiRes qw(time);
use URI::Encode;

use strict;

#Silent phone home log URL receiver
{
    package WebServer;
    use HTTP::Server::Simple::CGI;
    use base qw(HTTP::Server::Simple::CGI);
    my %dispatch = ("/deposit" => \&get_deposit);

    sub get_deposit {
        my ($cgi) = @_;
        my @contents = $cgi->param("DEPOSIT");
        open(DEPOSIT, ">>", "deposit-log");
        foreach my $content (@contents) { print(DEPOSIT "$content\n"); }
        close(DEPOSIT);
        return 0;
    }

    sub handle_request {
        my ($self, $cgi) = @_;
        my $path = $cgi->path_info();
        my $handler = $dispatch{$path};
        if(ref($handler) eq "CODE") { $handler->($cgi); }
        return 0;
    }
}

my $usage = "Debug Log Querying Client Options:

Required:

Optional:
    --log,-l    <path>      Enables logging of all sent requests and received output.

    --port,-p   <integer>   Attempt to use selected port for phone home receiver.
                            Default: 9001.

    --session,-s            Enables logging of user input history for next session.

    --help                  Display this message.

Example Usage:

    perl cli-client --log output.log --port 9001 --session

";

my $command_usage = "Available commands:
  ALIAS <URI> <STRING>
  EXIT
  JX
  LIST
  PULL <URI/ALIAS>
  QUERY <URI/ALIAS> <STRING>
  RM <URI/ALIAS>
";

my %OPT;
try {
    GetOptions(
        "log=s" => \$OPT{log},
        "port=s" => \$OPT{port},
        "session|?" => \$OPT{session},
        "help|?" => sub { print $usage; exit(0); },
    );
}
catch Error::Simple with {
    my $E = shift;
    print STDERR $E->{-text};
    die "Failed to parse command line options.\n";
};

my $port = $OPT{port};
if(!$port) { $port = 9001; }
my $host = hostname();
my $spid = WebServer->new($port)->background();
print(STDERR "$!\n");
if($spid) { print(STDOUT "Phone home server established at $host:$port with PID $spid.\n\n"); }

my $client = 0;
my $err = 0;
my $server = "";
my $log = $OPT{log};
my $session = $OPT{session};
if($err) {
    print(STDERR "Could not find $err required arguments.\n");
    print_help();
}

my %aliases = ();
my %logs = ();
my $prompt = " \$ ";
my $term = Term::ReadLine->new("tlq");
$client = LWP::UserAgent->new(
    protocols_allowed => ["http", "https"],
    timeout => 10
);
$client->env_proxy;
if($session) {
    open(HISTORY, ">>", "session.log") or die "Could not open session log for writing.\n";
    open(READHIST, "session.log");
    while(my $line = <READHIST>) {
        chomp($line);
        $term->add_history($line);
    }
    close(READHIST);
}
print(STDOUT $command_usage);
while(defined(my $input = $term->readline($prompt))) {
    get_info("deposit-log");
    my @parts = split(' ', $input);
    my $action = uc($parts[0]);
    my $destination = $parts[1];
    my $target = $parts[2];
    my $result = "";
    $input = uc($action) . " $destination $target";
    $input =~ s/\s+$//;
    $term->add_history($input) if /\S/;
    if($session) { print(HISTORY "$input\n"); }
    if(uc($input) eq "QUIT" or uc($input) eq "EXIT") {
        kill(9, $spid);
        exit(0);
    } 
    if($action eq "JX") {
        if(!-e "./jx_test") { system("cp ../cctools-source/dttools/src/jx_test ."); }
        $result = system("./jx_test");
        print(STDOUT "$result\n");
        print_result("JX", $result);
        next; 
    }
    if($action ne "LIST" and !$destination) { print_command_help(); } 
    elsif($action eq "PULL") {
        if(!$destination) {
            print_command_help();
            next;
        }
        $server = $destination;
        if(exists($aliases{$server})) { $server = $aliases{$server}; }
        $result = URI::Encode->new( { encode_reserved => 0 } )->decode(request("PULL", $server, query_to_json($target)));
        print(STDOUT "$result\n");
        print_result("PULL $server $target", $result);
        next;
    }
    elsif($action eq "QUERY") {
        if(!$destination) {
            print_command_help();
            next;
        }
        my $i = 3;
        while(scalar(@parts) > $i) {
            $target = $target . " $parts[$i]";
            $i++;
        }
        $server = $destination;
        if(exists($aliases{$server})) { $server = $aliases{$server}; }
        my $time = time();
        $result = URI::Encode->new( { encode_reserved => 0 } )->decode(request("QUERY", $server, query_to_json($target)));
        $time = time() - $time;
        print(STDOUT "$result\n");
        print(STDERR "Query duration: $time\n");
        print_result("QUERY $server $target", $result);
        next; 
    }
    elsif($action eq "RM") {
        if(!$destination) {
            print_command_help();
            next;
        }
        $server = $destination;
        if(exists($aliases{$server})) { $server = $aliases{$server}; }
        $result = URI::Encode->new( { encode_reserved => 0 } )->decode(request("RM", $server, query_to_json($target)));
        print(STDOUT "$result\n");
        print_result("RM $server $target", $result);
        next;
    }
    elsif($action eq "ALIAS") {
        $aliases{$target} = $destination;
        print(STDOUT "Please use alias $target to access $destination.\n");
    }
    elsif($action eq "EXIT" or $action eq "QUIT") { $result = request($action, $destination); }
    elsif($action eq "LIST") {
        $result = list_logs();
        print(STDOUT "$result\n");
    }
    else { print_command_help(); } 
    if($action ne "QUERY") { print_result($input, $result); }
}

if($session) { close(HISTORY); }
kill(9, $spid);
exit(0);

sub get_info {
    my ($file) = @_;
    open(FILE, $file);
    while(my $line = <FILE>) {
        if($line =~ m/^(?<command>.+) created log (?<log>\S+) queryable at (?<uri>\S+).$/) {
            my $log = $+{log};
            my $command = $+{command};
            my $uri = $+{uri};
            my $host = "";
            if(!exists $logs{$uri}) {
                if($uri =~ m/(?<host>https?:\/\/\S+\/).+/) { $host = $+{host}; }
                $logs{$uri} = {};
                $logs{$uri}{log} = $log;
                $logs{$uri}{command} = $command;
                $logs{$uri}{uri} = $uri;
                $logs{$uri}{host} = $host;
            }
        }
    }
    close(FILE);
    return 0;
}

sub list_logs {
    my $return = "";
    foreach my $c (keys(%logs)) {
        my $dump = Dumper($logs{$c});
        $return = $return . "$c =>\n" . $dump . "\n";
    }
    return $return;
}

sub print_result {
    my ($input, $result) = @_;
    chomp($result);
    if($log) {
        open(LOG, ">>", $log) or die "Could not open $log for log writing.\n";
        print(LOG "$input =>\n$result\n");
        close(LOG);
    }
}

sub query_to_json {
    my ($query) = @_;
    my %object;
    $object{query} = $query;
    my $json = JSON->new->encode(\%object);
    $json = URI::Encode->new( { encode_reserved => 0 } )->encode($json);
    return $json;
}

sub request {
    my ($action, $destination, $content) = @_;
    my $content = 0;
    my $http = $destination;
    my $response = 0;
    if($action eq "PULL") {
        $http = $destination . "/files";
        $response = $client->put($http, "Content-Type" => "text/plain", Content => $content);
    }
    elsif($action eq "QUERY") {
        $response = $client->put($http, "Content-Type" => "text/plain", Content => $content);
    }
    elsif($action eq "QUIT" or $action eq "EXIT") {
        $http = $logs{$destination}{host} . "/exit";
        $response = $client->get($http);
    }
    elsif($action eq "RM") {
        $http = $destination . "/rm";
        $response = $client->put($http, "Content-Type" => "text/plain", Content => $content);
    }
    else { return "Request type $action not supported."; }
    if($response->is_success) { return $response->decoded_content; }
    else { return $response->status_line; }
}

sub signal_handler {
    print(STDERR "\nCaught '$!' signal. Terminating process.\n");
    kill(9, $spid);
    exit(1);
}

sub print_help {
    print(STDERR $usage);
    exit(1);
}

sub print_command_help {
    print(STDERR "Incorrect command syntax used. Missing field(s).\n\n");
    print(STDERR $command_usage);
}

# vim: tabstop=8 shiftwidth=4 softtabstop=4 expandtab shiftround autoindent
