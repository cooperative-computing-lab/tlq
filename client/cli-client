#! /usr/bin/env perl

use Data::Dumper;
use Error qw(:try);
use Error::Simple;
use Getopt::Long qw(:config no_ignore_case); #Parse options
use JSON;
use LWP::UserAgent; #Send requests and receive responses
use sigtrap qw/handler signal_handler INT TERM/; #Catch SIGINT and SIGTERM
use Term::ReadLine; #Use a REPL for querying

use strict;

my $usage = "Debug Log Querying Client Options:

Required:

Optional:
    --log,-l    <path>      Enables logging of all sent requests and received output.

    --session,-s            Enables logging of user input history for next session.

    --help                  Display this message.

Example Usage:

    perl logquery --log output.log

";

my $query_usage = "Query structure: <action> [URI] [options]

Where <action> is one of: ALIAS, EXIT, LIST, QUERY, QUIT

And [options] is one of: String for action ALIAS or String for action QUERY
";

my %OPT;
try {
    GetOptions(
        "log=s" => \$OPT{log},
        "session|?" => \$OPT{session},
        "help|?" => sub { print $usage; exit(0); },
    );
}
catch Error::Simple with {
    my $E = shift;
    print STDERR $E->{-text};
    die "Failed to parse command line options.\n";
};

my $client = 0;
my $err = 0;
my $log = $OPT{log};
my $session = $OPT{session};
if($err) {
    print(STDERR "Could not find $err required arguments.\n");
    print_help();
}

my %aliases = ();
my %components = ();
my $prompt = "Enter Query > ";
my $term = Term::ReadLine->new("logquery");
$client = LWP::UserAgent->new(
    protocols_allowed => ["http", "https"],
    timeout => 10
);
$client->env_proxy;
if($session) {
    open(HISTORY, ">>", "cli-session") or die "Could not open session log for writing.\n";
    open(READHIST, "cli-session");
    while(my $line = <READHIST>) {
        chomp($line);
        $term->add_history($line);
    }
    close(READHIST);
}
print(STDOUT $query_usage);
while(defined(my $input = $term->readline($prompt))) {
    get_info("deposit-log");
    $term->add_history($input) if /\S/;
    if($session) { print(HISTORY "$input\n"); }
    if(uc($input) eq "QUIT" or uc($input) eq "EXIT") { exit(0); }
    my @parts = split(' ', $input);
    my $action = uc($parts[0]);
    my $destination = $parts[1];
    my $target = $parts[2];
    my $result = "";
    if(exists($aliases{$destination})) { $destination = $aliases{$destination}; } 
    if($action ne "LIST" and !$destination) { print_query_help(); }
    elsif($action eq "QUERY") {
        my $index = 3;
        while($index < scalar(@parts)) {
            $target = $target . " " . $parts[$index];
            $index++;
        }
        if(!$target) {
            print_query_help();
            next;
        }
        my @subqueries = query_parse_dag($target);
        foreach my $subquery (@subqueries) {
            $result = request($action, $destination, query_to_json($subquery));
            print_result($subquery, $result);
        }
    }
    elsif($action eq "ALIAS") {
        $aliases{$target} = $destination;
        print(STDOUT "Please use alias '$target' to access '$destination' URI.\n");
    }
    elsif($action eq "EXIT" or $action eq "QUIT") { $result = request($action, $destination); }
    elsif($action eq "LIST") { $result = list_components(); }
    else { print_query_help(); } 
    if($action ne "QUERY") { print_result($input, $result); }
}

if($session) { close(HISTORY); }
exit(0);

sub get_info {
    my ($file) = @_;
    open(FILE, $file);
    while(my $line = <FILE>) {
        if($line =~ m/^Component (?<uuid>\S+) created log\(s\) \[(?<logs>.*)\] with command (?<command>.+) queryable at (?<uri>\S+) and has parent (?<puuid>\S+).$/) {
            my $uuid = $+{uuid};
            my $puuid = $+{puuid};
            my $logs = $+{logs};
            my $command = $+{command};
            my $uri = $+{uri};
            my $host = "";
            if(!exists $components{$uri}) {
                if($uri =~ m/(?<host>https?:\/\/\S+\/).+/) { $host = $+{host}; }
                $components{$uri} = {};
                $components{$uri}{uuid} = $uuid;
                $components{$uri}{parent} = $puuid;
                $components{$uri}{logs} = $logs;
                $components{$uri}{command} = $command;
                $components{$uri}{uri} = $uri;
                $components{$uri}{host} = $host;
            }
        }
    }
    close(FILE);
    return 0;
}

sub list_components {
    my $return = "";
    foreach my $c (keys(%components)) {
        my $dump = Dumper($components{$c});
        $return = $return . "$c =>\n" . $dump . "\n";
    }
    return $return;
}

sub parse_query_dag {
    my ($query) = @_;
    my @parts = split($query, ';');
    my %dag;
    foreach my $part (@parts) {
        if($part =~ m/^(?<id>\S+)[uuid="(?<uuid>\S+)"];$/) {
            $dag{$+{id}} = {};
            $dag{$+{id}}{uuid} = $+{uuid}; 
        } 
        elsif($part =~ m/^(?<id>\S+)[uuid="(?<uuid>\S+)"\s*,\s*(?<conditions>.+)];$/) {
            $dag{$+{id}} = {};
            $dag{$+{id}}{uuid} = $+{uuid};
            #TODO Add extra conditionals
        }
        elsif($part =~ m/^(?<id>\S+):(?<selects.*);$/) {
            #TODO Add selects and conditions
        }
        elsif($part =~ m/^(?<source>\S+)\s*->\s*(?<dest>\S+);$/) {
            if(exists $dag{$+{source}}{children}) { $dag{$+{source}}{children} = $dag{$+{source}}{children} . ',' . $+{dest}; }
            else { $dag{$+{source}}{children} = $+{dest}; }
            $dag{$+{dest}}{parent} = $+{source};
        }
    }
    foreach my $key (keys(%dag)) {
        my %node = $dag{$key};
        my $nodestring = "$node{uuid};$node{conditions};$node{selects}";
        push(@subqueries, $nodestring);
    }
    my @subqueries;
    return @subqueries;
}

sub print_result {
    my ($input, $result) = @_;
    chomp($result);
    if($log) {
        open(LOG, ">>", $log) or die "Could not open $log for log writing.\n";
        print(LOG "$input =>\n$result\n");
        close(LOG);
    } 
    print(STDOUT "$result\n");
}

sub query_to_json {
    my ($query) = @_;
    my @subqueries = parse_query_dag($query);
    my %object;
    my ($id, $conditions, $selects) = split($query, ';');
    if(!$selects) { $selects = "*"; }
    my $query = "SELECT $selects FROM $id";
    if($conditions) { $query = $query . " WHERE $conditions"; }
    $object{query} = $query . ";";
    my $json = encode_json(%object);
    return $json;
}

sub request {
    my ($action, $destination, $target) = @_;
    my $content = 0;
    my $http = $destination;
    my $response = 0;
    if($action eq "QUERY") { $content = $target; }
    elsif($action eq "QUIT" or $action eq "EXIT") { $http = $components{$destination}{host} . "/exit"; }
    if($action eq "QUIT" or $action eq "EXIT") { $response = $client->get($http); }
    elsif($action eq "QUERY") { $response = $client->put($http, "Content-Type" => "text/plain", Content => $content); }
    else { return "Request type '$action' not supported."; }
    if($response->is_success) { return $response->decoded_content; }
    else { return $response->status_line; }
}

sub signal_handler {
    print(STDERR "\nCaught '$!' signal. Terminating process.\n");
    exit(1);
}

sub print_help {
    print(STDERR $usage);
    exit(1);
}

sub print_query_help {
    print(STDERR "Incorrect query syntax used. Missing field(s).\n\n");
    print(STDERR $query_usage);
}

# vim: tabstop=8 shiftwidth=4 softtabstop=4 expandtab shiftround autoindent
