#! /usr/bin/env perl

use Data::Dumper;
use Error qw(:try);
use Error::Simple;
use Getopt::Long qw(:config no_ignore_case);
use JSON;
use LWP::UserAgent;
use sigtrap qw/handler signal_handler INT TERM/;
use Term::ReadLine;
use Time::HiRes qw(time);
use URI::Encode;

use strict;

my $usage = "Debug Log Querying Client Options:

Required:

Optional:
    --log,-l    <path>      Enables logging of all sent requests and received output.

    --session,-s            Enables logging of user input history for next session.

    --help                  Display this message.

Example Usage:

    perl cli-client --log output.log

";

my $command_usage = "Available commands:
  ALIAS <URI> <STRING>
  EXIT
  JX <URI/ALIAS>
  PULL <URI/ALIAS>
  QUERY <URI/ALIAS> <STRING>
  RM <URI/ALIAS>
";

my %OPT;
try {
    GetOptions(
        "log=s" => \$OPT{log},
        "session|?" => \$OPT{session},
        "help|?" => sub { print $usage; exit(0); },
    );
}
catch Error::Simple with {
    my $E = shift;
    print STDERR $E->{-text};
    die "Failed to parse command line options.\n";
};

my $client = 0;
my $err = 0;
my $jx = "";
my $jxmode = 0;
my $server = "";
my $log = $OPT{log};
my $session = $OPT{session};
if($err) {
    print(STDERR "Could not find $err required arguments.\n");
    print_help();
}

my %aliases = ();
my %components = ();
my $prompt = " \$ ";
my $term = Term::ReadLine->new("tlq");
$client = LWP::UserAgent->new(
    protocols_allowed => ["http", "https"],
    timeout => 10
);
$client->env_proxy;
if($session) {
    open(HISTORY, ">>", "session.log") or die "Could not open session log for writing.\n";
    open(READHIST, "session.log");
    while(my $line = <READHIST>) {
        chomp($line);
        $term->add_history($line);
    }
    close(READHIST);
}
print(STDOUT $command_usage);
while(defined(my $input = $term->readline($prompt))) {
    get_info("deposit-log");
    my @parts = split(' ', $input);
    my $action = uc($parts[0]);
    my $destination = $parts[1];
    my $target = $parts[2];
    my $result = "";
    if($jxmode) {
        if($action eq "") {
            $prompt = " \$ ";
            $jxmode = 0;
            if(exists($aliases{$server})) { $server = $aliases{$server}; }
            $result = URI::Encode->new( { encode_reserved => 0 } )->decode(request("JX", $server, query_to_json($jx)));
            #print(STDOUT "$result\n");
            my $json = parse_json_from_html($result);
            open(JX, ">>", "tmp.json");
            print(JX "$json");
            close(JX);
            #$result = `./jx_query $json '$jx'`;
            $result = `./jx_query ./tmp.json '$jx'`;
            print(STDOUT "$result\n");
            unlink("tmp.json");
            print_result("JX $jx", $result);
            next;
        }
        $jx = $jx . $input;
        next;
    }
    $input = uc($action) . " $destination $target";
    $input =~ s/\s+$//;
    $term->add_history($input) if /\S/;
    if($session) { print(HISTORY "$input\n"); }
    if(uc($input) eq "QUIT" or uc($input) eq "EXIT") { exit(0); } 
    if($action ne "LIST" and !$destination) { print_command_help(); }
    elsif($action eq "JX") {
        if(!$destination) {
            print_command_help();
            next;
        }
        $server = $destination;
        $jxmode = 1;
        $jx = "";
        $prompt = " > ";
        next; 
    }
    elsif($action eq "PULL") {
        if(!$destination) {
            print_command_help();
            next;
        }
        $server = $destination;
        if(exists($aliases{$server})) { $server = $aliases{$server}; }
        $result = URI::Encode->new( { encode_reserved => 0 } )->decode(request("PULL", $server, query_to_json($target)));
        print(STDOUT "$result\n");
        print_result("PULL $server $target", $result);
        next;
    }
    elsif($action eq "QUERY") {
        if(!$destination) {
            print_command_help();
            next;
        }
        my $i = 3;
        while(scalar(@parts) > $i) {
            $target = $target . " $parts[$i]";
            $i++;
        }
        $server = $destination;
        if(exists($aliases{$server})) { $server = $aliases{$server}; }
        my $time = time();
        $result = URI::Encode->new( { encode_reserved => 0 } )->decode(request("QUERY", $server, query_to_json($target)));
        $time = time() - $time;
        print(STDOUT "$result\n");
        print(STDERR "Query duration: $time\n");
        print_result("QUERY $server $target", $result);
        next; 
    }
    elsif($action eq "RM") {
        if(!$destination) {
            print_command_help();
            next;
        }
        $server = $destination;
        if(exists($aliases{$server})) { $server = $aliases{$server}; }
        $result = URI::Encode->new( { encode_reserved => 0 } )->decode(request("RM", $server, query_to_json($target)));
        print(STDOUT "$result\n");
        print_result("RM $server $target", $result);
        next;
    }
    elsif($action eq "ALIAS") {
        $aliases{$target} = $destination;
        print(STDOUT "Please use alias $target to access $destination.\n");
    }
    elsif($action eq "EXIT" or $action eq "QUIT") { $result = request($action, $destination); }
    elsif($action eq "LIST") {
        $result = list_components();
        print(STDOUT "$result\n");
    }
    else { print_command_help(); } 
    if($action ne "QUERY") { print_result($input, $result); }
}

if($session) { close(HISTORY); }
exit(0);

sub get_info {
    my ($file) = @_;
    open(FILE, $file);
    while(my $line = <FILE>) {
        if($line =~ m/^Component (?<uuid>\S+) created log\(s\) \[(?<logs>.*)\] with command (?<command>.+) queryable at (?<uri>\S+) and has parent (?<puuid>\S+).$/) {
            my $uuid = $+{uuid};
            my $puuid = $+{puuid};
            my $logs = $+{logs};
            my $command = $+{command};
            my $uri = $+{uri};
            my $host = "";
            if(!exists $components{$uri}) {
                if($uri =~ m/(?<host>https?:\/\/\S+\/).+/) { $host = $+{host}; }
                $components{$uri} = {};
                $components{$uri}{uuid} = $uuid;
                $components{$uri}{parent} = $puuid;
                $components{$uri}{logs} = $logs;
                $components{$uri}{command} = $command;
                $components{$uri}{uri} = $uri;
                $components{$uri}{host} = $host;
            }
        }
    }
    close(FILE);
    return 0;
}

sub list_components {
    my $return = "";
    foreach my $c (keys(%components)) {
        my $dump = Dumper($components{$c});
        $return = $return . "$c =>\n" . $dump . "\n";
    }
    return $return;
}

sub parse_json_from_html {
    my ($html) = @_;
    my @lines = split("\n", $html);
    my $flag = 0;
    foreach my $line (@lines) {
        if($flag) { return $line; }
        elsif($line =~ m/<h1>Dumping raw contents of/) { $flag = 1; }
    }
    return 1;
}

sub print_result {
    my ($input, $result) = @_;
    chomp($result);
    if($log) {
        open(LOG, ">>", $log) or die "Could not open $log for log writing.\n";
        print(LOG "$input =>\n$result\n");
        close(LOG);
    }
}

sub query_to_json {
    my ($query) = @_;
    my %object;
    $object{query} = $query;
    my $json = JSON->new->encode(\%object);
    $json = URI::Encode->new( { encode_reserved => 0 } )->encode($json);
    return $json;
}

sub request {
    my ($action, $destination, $target) = @_;
    my $content = 0;
    my $http = $destination;
    my $response = 0;
    if($action eq "JX") {
        $content = $target;
        $response = $client->put($http, "Content-Type" => "text/plain", Content => $content);
    }
    elsif($action eq "PULL") {
        $http = $destination . "/files";
        $content = $target;
        $response = $client->put($http, "Content-Type" => "text/plain", Content => $content);
    }
    elsif($action eq "QUERY") {
        $content = $target;
        $response = $client->put($http, "Content-Type" => "text/plain", Content => $content);
    }
    elsif($action eq "QUIT" or $action eq "EXIT") {
        $http = $components{$destination}{host} . "/exit";
        $response = $client->get($http);
    }
    elsif($action eq "RM") {
        $http = $destination . "/rm";
        $response = $client->put($http, "Content-Type" => "text/plain", Content => $content);
    }
    else { return "Request type $action not supported."; }
    if($response->is_success) { return $response->decoded_content; }
    else { return $response->status_line; }
}

sub signal_handler {
    print(STDERR "\nCaught '$!' signal. Terminating process.\n");
    exit(1);
}

sub print_help {
    print(STDERR $usage);
    exit(1);
}

sub print_command_help {
    print(STDERR "Incorrect command syntax used. Missing field(s).\n\n");
    print(STDERR $command_usage);
}

# vim: tabstop=8 shiftwidth=4 softtabstop=4 expandtab shiftround autoindent
