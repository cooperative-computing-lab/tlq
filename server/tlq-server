#! /usr/bin/env perl

use Error qw(:try);
use Error::Simple;
use Getopt::Long qw(:config no_ignore_case);
use sigtrap qw/handler signal_handler INT TERM/;
use Sys::Hostname;

use strict;

my $usage = "TLQ Log Watch Server Options:

Required:

Optional:
    --dir,-d    <path>      Use the specified path for TLQ's working directory.
                            Default: /tmp/tlq
    --port,-p   <integer>   Attempt to use selected port.
                            Default: 9000.

    --help                  Display this message.

Example Usage:

    perl tlq-server --port 9000

";

my %OPT;
try {
    GetOptions(
        "dir=s" => \$OPT{dir},
        "port=s" => \$OPT{port},
        "help|?" => sub { print $usage; exit(0); },
    );
}
catch Error::Simple with {
    my $E = shift;
    print STDERR $E->{-text};
    die "Failed to parse command line options.\n";
};

my $client = 0;
my $err = 0;
our $dir = $OPT{dir};
my $port = $OPT{port};
if(!$dir) { $dir = "/tmp/tlq"; }
if(!$port) { $port = 9000; }
if($err) { print_help(); }
my $host = hostname();

#Define application-specific web server handling
{
    package WebServer;
    use Data::Dumper;
    use HTTP::Server::Simple::CGI;
    use JSON;
    use Sys::Hostname;
    use threads;
    use URI::Encode;
    use base qw(HTTP::Server::Simple::CGI);

    my %components; #Components have a UUID and a list of files
    my %logs; #Logs have a UUID, path, JSON path, type, component, and size
    my %parsers; #Parsers have an type ID, path, and executor
    #my $dir = "/disk/d11/tlq";
    if(!(-e $dir)) { mkdir($dir); }
    else {
        unlink("$dir/lookup-log");
        unlink("$dir/deposit-queries");
        unlink("$dir/deposit-parser");
    }
    chmod(0766, $dir);
    opendir(DIR, "parsers");
    my @localparsers = grep(/-parser$/,readdir(DIR));
    closedir(DIR);
    foreach my $p (@localparsers) {
        system("cp parsers/$p $dir/$p");
        my $parseparts =~ m/(?<type>\S+)-parser$/;
        my $type = $+{type};
        $parsers{$type} = {};
        $parsers{$type}{path} = "$dir/$p";
        $parsers{$type}{exec} = "perl";
    }
    my $host = hostname();
    my $log_thread = threads->create("watch_logs");
    $log_thread->detach();
    my %dispatch = (
        "/query" => \&run_query,
        "/jx" => \&send_json,
        "/files" => \&send_file,
        "/rm" => \&rm_component
    );

    sub check_deposit {
        open(DEPOSIT, "$dir/deposit-log");
        while(my $line = <DEPOSIT>) {
            chomp($line);
            my @parts = split(' ', $line);
            my ($component, $log, $type, $uuid, $flag) = @parts;
            if(exists($logs{$uuid})) { next; }
            $logs{$uuid} = {};
            $logs{$uuid}{component} = $component;
            $logs{$uuid}{flag} = $flag;
            $logs{$uuid}{json} = "$dir/$uuid.json";
            $logs{$uuid}{original} = $log;
            $logs{$uuid}{path} = $log;
            $logs{$uuid}{size} = 0;
            $logs{$uuid}{type} = $type;
            if($flag) { $logs{$uuid}{path} = "$dir/$uuid.log"; }
            if(!exists $components{$component}) {
                $components{$component} = {};
                $components{$component}{files} = $uuid;
            }
            else { $components{$component}{files} = $components{$component}{files} . " $uuid"; }
        }
        close(DEPOSIT);
    }

    sub check_file {
        my ($file) = @_;
        if(!$file) { return 0; }
        if(exists($logs{$file})) { $file = $logs{$file}{path}; }
        if(!(-e $file)) { return 0; }
        my $result = open(FILE, $file);
        close(FILE);
        if(!$result) { return 0; }
        return $file;
    } 

    sub component_get_files {
        my ($component) = @_;
        my @array = split($components{$component}{files}, ' ');
        return @array;
    }

    sub run_query {
        my ($cgi) = @_;
        my $query = query_from_json($cgi->param("PUTDATA"));
        my $data = "";
        my %encode;
        $encode{query} = $query;
        $encode{result} = `$query`;
        my $result = JSON->new->encode(\%encode);
        print(STDOUT "HTTP/1.0 200 OK\n");
        print(STDOUT $cgi->header);
        print(STDOUT $cgi->start_html("Record(s) retrieved."));
        print(STDOUT "$result from query $query");
        print(STDOUT $cgi->end_html);
        return 0;
    }

    sub send_json {
        my ($cgi) = @_;
        my ($uuid, $json);
        if($cgi->path_info() =~ m/jx\/(?<uuid>\S+)/) { $uuid = $+{uuid}; }
        foreach my $l (keys(%logs)) { if($logs{$l}{component} == $uuid) { $json = $logs{$l}{json}; } }
        $json = check_file($json);
        return transfer($cgi, $json);
    }

    sub send_file {
        my ($cgi) = @_;
        my $file = query_from_json($cgi->param("PUTDATA"));
        $file = check_file($file);
        return transfer($cgi, $file);
    }

    sub rm_component {
        my ($cgi) = @_;
        my $component = query_from_json($cgi->param("PUTDATA"));
        my ($err, $flag) = 0;
        my @files = split(' ', $components{$component}{files});
        my @failures;
        foreach my $f (@files) {
            $f = check_file($f);
            my $result = unlink($f);
            if(!$result) {
                $err = $!;
                $flag = 1;
                push(@failures, $f);
            }
        }
        if($flag) {
            print(STDOUT "HTTP/1.0 200 OK\n");
            print(STDOUT $cgi->header);
            print(STDOUT $cgi->start_html("Component $component not deleted"));
            print(STDOUT $cgi->h1("Could not delete the following files:\n"));
            foreach my $f (@failures) { print(STDOUT "$f\n"); }
            print(STDOUT "Error: $err\n");
            print(STDOUT $cgi->end_html);
            return 1;
        }
        else {
            print(STDOUT "HTTP/1.0 200 OK\n");
            print(STDOUT $cgi->header);
            print(STDOUT $cgi->start_html("Component $component deleted"));
            print(STDOUT $cgi->h1("Deleted the following files:\n"));
            foreach my $f (@files) { print(STDOUT "$f\n"); }
            print(STDOUT $cgi->end_html);
            return 0;
        }
    }

    sub transfer {
        my ($cgi, $file) = @_;
        if(!$file) {
            print(STDOUT "HTTP/1.0 500 Internal server error\n");
            print(STDOUT $cgi->header);
            print(STDOUT $cgi->start_html("File not found."));
            print(STDOUT $cgi->end_html);
            return 1;
        }
        my $rawtext = "";
        open(FILE, $file);
        while(my $line = <FILE>) { $rawtext = $rawtext . $line; }
        close(FILE);
        print(STDOUT "HTTP/1.0 200 OK\n");
        print(STDOUT $cgi->header);
        print(STDOUT $cgi->start_html("Log sent"));
        print(STDOUT $cgi->h1("Dumping raw contents of '$file' to STDOUT"));
        print(STDOUT "\n$rawtext");
        print(STDOUT $cgi->end_html);
        return 0;
    }

    sub parse_logs {
        my ($type) = @_;
        my $parser = $parsers{$type}{path};
        my $exec = $parsers{$type}{exec};
        my @toparse;
        foreach my $uuid (keys(%logs)) { if($logs{$uuid}{type} eq $type and ($logs{$uuid}{size} < -s $logs{$uuid}{path})) { push(@toparse, $uuid); } }
        foreach my $uuid (@toparse) {
            my $component = $logs{$uuid}{component};
            my $path = $logs{$uuid}{path};
            print(STDERR "Calling $exec $parser $path $component\n");
            my $parsed = `$exec $parser $path $component`;
            my $json = $logs{$uuid}{json};
            if(-e $json) { unlink($json); }
            open(QUERIES, ">>", $json);
            print(QUERIES $parsed);
            close(QUERIES);
        }
        return 0;
    }

    sub watch_logs {
        my $flag = 1;
        while($flag) {
            check_deposit();
            foreach my $type (keys(%parsers)) { parse_logs($type); }
            foreach my $uuid (keys(%logs)) {
                if(!$logs{$uuid}{flag} and -e $logs{$uuid}{original} and $logs{$uuid}{size} < -s $logs{$uuid}{original}) { system("cp $logs{$uuid}{original} $logs{$uuid}{path}"); }
                $logs{$uuid}{size} = -s $logs{$uuid}{path};
            }
            sleep(10);
        }
        print(STDERR "\nExiting log watcher thread.\n");
        threads->exit();
        return 0;
    }

    sub query_from_json {
        my ($json) = @_;
        $json = URI::Encode->new( { encode_reserved => 0 } )->decode($json);
        my $queryref = JSON->new->decode($json);
        my %query = %$queryref;
        my $dump = Dumper(%query);
        return $query{query};
    }

    sub handle_request {
        my ($self, $cgi) = @_;
        my $path = $cgi->path_info();
        if($path =~ m/jx/) { $path = "/jx"; }
        elsif($path =~ m/query/) { $path = "/query"; }
        my $handler = $dispatch{$path};
        check_deposit();
        if(ref($handler) eq "CODE") { $handler->($cgi); }
        else {
            print(STDOUT "HTTP/1.0 404 Not found\n");
            print(STDOUT $cgi->header);
            print(STDOUT $cgi->start_html("Not found"));
            print(STDOUT $cgi->h1("Not found"));
            print(STDOUT $cgi->end_html);
        }
        return 0;
    }
}

my $server = WebServer->new($port);
print(STDOUT "Server established at $host:$port.\n\n");
$server->run();
exit(0);

sub signal_handler {
    print(STDERR "\nCaught '$!' signal. Terminating process.\n");
    exit(1);
}

sub print_help {
    print(STDOUT $usage);
    exit(1);
}

# vim: tabstop=8 shiftwidth=4 softtabstop=4 expandtab shiftround autoindent
