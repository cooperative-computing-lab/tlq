#! /usr/bin/env perl

use Error qw(:try);
use Error::Simple;
use Getopt::Long qw(:config no_ignore_case);
use IO::Socket::PortState qw(check_ports);
use sigtrap qw/handler signal_handler INT TERM/;
use Sys::Hostname;

use strict;

#Define application-specific web server handling
{
    package WebServer;
    use Data::Dumper;
    use File::Basename;
    use HTTP::Server::Simple::CGI;
    use JSON;
    use Sys::Hostname;
    use threads;
    use Thread::Semaphore;
    use URI::Encode;
    use base qw(HTTP::Server::Simple::CGI);

    my $dir = "/tmp/tlq";
    if(!(-e $dir)) { mkdir($dir); }
    else {
        unlink("$dir/lookup-log");
        unlink("$dir/deposit-queries");
        unlink("$dir/deposit-parser");
    }
    chmod(0766, $dir);
    opendir(DIR, "parsers");
    my @localparsers = grep(/-parser$/,readdir(DIR));
    closedir(DIR);
    open(DEPOSIT, ">>", "$dir/deposit-parser");
    foreach my $p (@localparsers) {
        system("cp parsers/$p $dir/$p");
        my @parseparts = split('-', $p);
        my $type = $parseparts[0];
        print(DEPOSIT "$dir/$p $type perl\n");
    }
    close(DEPOSIT);
    my $sem = Thread::Semaphore->new();
    my $host = hostname();
    my $log_thread = threads->create("watch_logs");
    $log_thread->detach();
    my %dispatch = (
        "/components" => \&component_query,
        "/exit" => \&cleanup,
        "/files" => \&send_file,
    );
    my %components;
    my %logs;
    my %parsers;
    my %tables;

    sub check_deposit {
        open(DEPOSIT, "$dir/deposit-log");
        while(my $line = <DEPOSIT>) {
            chomp($line);
            my @parts = split(' ', $line);
            my ($component, $log, $type, $hash) = @parts;
            if(exists($logs{$hash})) { next; }
            $logs{$hash} = {};
            $logs{$hash}{path} = $log;
            $logs{$hash}{type} = $type;
            $logs{$hash}{uuid} = $component;
            if(!exists $components{$component}) {
                $components{$component} = {};
                $components{$component}{files} = $hash;
            }
            else { $components{$component}{files} = $components{$component}{files} . " $hash"; }
        }
        close(DEPOSIT);
    }

    sub check_file {
        my ($file) = @_;
        if(!$file) { return 1; }
        if(exists($logs{$file})) { $file = $logs{$file}{path}; }
        my $result;
        if(!(-e $file)) { return 1; }
        $result = open(FILE, $file);
        close(FILE);
        if(!$result) { return 1; }
        return 0;
    } 

    sub check_parsers {
        open(DEPOSIT, "$dir/deposit-parser");
        while(my $line = <DEPOSIT>) {
            chomp($line);
            my @parts = split(' ', $line);
            my ($path, $type, $interpreter) = @parts;
            if(exists($parsers{$type})) { next; }
            $parsers{$type} = {};
            $parsers{$type}{path} = $path;
            $parsers{$type}{interpreter} = $interpreter;
        }
        close(DEPOSIT);
    }

    sub cleanup {
        my ($cgi) = @_;
        print(STDOUT "HTTP/1.0 200 OK\n");
        print(STDOUT $cgi->header);
        print(STDOUT $cgi->start_html("Shutdown request"));
        print(STDOUT $cgi->h1("Received shutdown request"));
        print(STDOUT $cgi->end_html);
        unlink("$dir/deposit-parser");
        unlink("$dir/deposit-queries");
        kill(-15, $$);
        kill(-15, getppid());
        exit 0;
    }

    sub component_get_files {
        my ($component) = @_;
        my @array = split($components{$component}{files}, ' ');
        return @array;
    }

    sub component_query {
        my ($cgi) = @_;
        my $component;
        my $file;
        if($cgi->path_info() =~ m/components\/(?<uri>\S+)(\/(?<file>\S+))?/) {
            $component = $+{uri};
            $file = $+{file};
        }
        else { return 1; }
        my @files;
        if(!$file) { @files = component_get_files($component); }
        else { push(@files, $file); }
        my $query = query_from_json($cgi->param("PUTDATA"));
        my $json = "";
        foreach my $f (@files) {
            my $manifest = $logs{$f}{json};
            my $result = execute_json_query($query, $manifest);
            if($result) { $json = $json . "$result\n"; }
        }
        print(STDOUT "HTTP/1.0 200 OK\n");
        print(STDOUT $cgi->header);
        print(STDOUT $cgi->start_html("Record(s) retrieved."));
        print(STDOUT "$json from query $query");
        print(STDOUT $cgi->end_html);
        return 0;
    }

    sub execute_json_query {
        my ($query, $manifest) = @_;
        my $result;
        my $json = "";
        open(MANIFEST, $manifest);
        while(my $line = <MANIFEST>) { $json = $json . $line; }
        close(MANIFEST);
        $json = JSON->new->encode($json);
        my %obj = %$json;
        $json = JSON->new->encode($query);
        my %qobj = %$json;
        my %final;
        my $allflag = 0;
        foreach my $q (keys(%qobj)) {
            if($q eq "KEY" and $qobj{$q} eq "VALUE") { $allflag = 1; }
            elsif(exists $obj{$q} and $qobj{$q} eq "VALUE") {
                $final{$q} = $obj{$q};
            }
            elsif(exists $obj{$q} and $obj{$q} != $qobj{$q}) {
                return 0;
            }
            elsif(exists $obj{$q} and $obj{$q} == $qobj{$q}) { 
                $final{$q} = $obj{$q};
            } 
        }
        if($allflag) {
            foreach my $o (keys(%obj)) {
                if(!exists $final{$o}) { $final{$o} = $obj{$o}; }
            }
        }
        if(scalar(keys(%final))) { $result = JSON->new->encode(\%final); }
        return $result;
    }

    sub send_file {
        my ($cgi) = @_;
        my $file = $cgi->url_param("file");
        if(check_file($file)) {
            print(STDOUT "HTTP/1.0 500 Internal server error\n");
            print(STDOUT $cgi->header);
            print(STDOUT $cgi->start_html("File not found.."));
            print(STDOUT $cgi->h1("File '$file' not found"));
            print(STDOUT $cgi->end_html);
            return 1;
        }
        if(exists($logs{$file})) { $file = $logs{$file}{path}; }
        my $rawtext = "";
        open(FILE, $file);
        while(my $line = <FILE>) { $rawtext = $rawtext . $line; }
        close(FILE);
        print(STDOUT "HTTP/1.0 200 OK\n");
        print(STDOUT $cgi->header);
        print(STDOUT $cgi->start_html("Log sent"));
        print(STDOUT $cgi->h1("Dumping raw contents of '$file' to STDOUT"));
        print(STDOUT "\n$rawtext");
        print(STDOUT $cgi->end_html);
        return 0;
    }

    sub parse_logs {
        my ($type) = @_;
        my $parser = $parsers{$type}{path};
        my $interpreter = $parsers{$type}{interpreter};
        my @toparse;
        foreach my $log (keys(%logs)) { if($logs{$log}{type} =~ m/$type/ and ($logs{$log}{size} < -s $logs{$log}{path})) { push(@toparse, $logs{$log}{path}); } }
        foreach my $log (@toparse) {
            my $component = $logs{$log}{uuid};
            my $parsed = `$interpreter $parser $log $component`;
            my $queryfile = "$dir/$component.json";
            $logs{$log}{json} = $queryfile;
            open(QUERIES, ">>", $queryfile);
            print(QUERIES $parsed);
            close(QUERIES);
        }
        return 0;
    }

    sub watch_logs {
        my $flag = 1;
        check_parsers();
        while($flag) {
            check_deposit();
            foreach my $type (keys(%parsers)) { parse_logs($type); }
            foreach my $log (keys(%logs)) { $logs{$log}{size} = -s $logs{$log}{path}; }
            sleep(10);
        }
        print(STDERR "\nExiting log watcher thread.\n");
        threads->exit();
        return 0;
    }

    sub query_from_json {
        my ($json) = @_;
        $json = URI::Encode->new( { encode_reserved => 0 } )->decode($json);
        my $queryref = JSON->new->decode($json);
        my %query = %$queryref;
        my $dump = Dumper(%query);
        return $query{query};
    }

    sub handle_request {
        my ($self, $cgi) = @_;
        my $path = $cgi->path_info();
        if($path =~ m/components/) { $path = "/components"; }
        my $handler = $dispatch{$path};
        check_deposit();
        check_parsers();
        if(ref($handler) eq "CODE") { $handler->($cgi); }
        else {
            print(STDOUT "HTTP/1.0 404 Not found\n");
            print(STDOUT $cgi->header);
            print(STDOUT $cgi->start_html("Not found"));
            print(STDOUT $cgi->h1("Not found"));
            print(STDOUT $cgi->end_html);
        }
        return 0;
    }
}

my $usage = "Debug Log Querying Server Options:

Required:

Optional:
    --port,-p   <integer>   Attempt to use selected port when server mode is used.
                            If attempt fails, the next available port will be used.
                            Default: 9000.

    --help                  Display this message.

Example Usage:

    perl server --port 9000

";

my %OPT;
try {
    GetOptions(
        "port=s" => \$OPT{port},
        "help|?" => sub { print $usage; exit(0); },
    );
}
catch Error::Simple with {
    my $E = shift;
    print STDERR $E->{-text};
    die "Failed to parse command line options.\n";
};

my $client = 0;
my $err = 0;
my $port = $OPT{port};
if(!$port) { $port = 9000; }
if($err) { print_help(); }

my %ports = ("tcp" => {});
my $timeout = 1;
my $start = $port;
my $end = $port + 500;
while($start < $end) {
    $ports{tcp}{$start} = {};
    $start++;
}
my $checked = check_ports("localhost", $timeout, \%ports);
my $valid = 0;
if($checked->{tcp}{$port}{open} == 1) {
    for my $p (sort(keys(%{$checked->{tcp}}))) {
        if($checked->{tcp}{$p}{open} == 0) {
            $port = $p;
            $valid = 1;
            last;
        }
    }
}
else { $valid = 1; }
if(!$valid) { print(STDERR "No available port found in range $port to $end. Terminating server.\n"); }
my $host = hostname();
my $server = WebServer->new($port);
print(STDOUT "Server established at $host:$port.\n\n");
$server->run();
exit(0);

sub signal_handler {
    print(STDERR "\nCaught '$!' signal. Terminating process.\n");
    exit(1);
}

sub print_help {
    print(STDOUT $usage);
    exit(1);
}

# vim: tabstop=8 shiftwidth=4 softtabstop=4 expandtab shiftround autoindent
