#! /usr/bin/env perl

use strict;
use DateTime;
use Digest::MD5 qw(md5_hex);
use List::MoreUtils qw(uniq);
my $usage = "Processes Record Type Log Parser Options:

Required:
    <log>	    Sets the path to the log file.
    <app>           Sets the name of the origin application/system of the log.

Example Usage:
    processes-parser ltrace.log testapp

";

if(@ARGV != 2) {
    print(STDERR $usage);
    exit 1;
}
my ($log, $app) = @ARGV;
my %processes = ();
my ($cmd, $host, $cmdpid, $cmdppid);
open(LOG, $log) or die "Could not open specified log file.\n";
while(my $line = <LOG>) {
    #Wrote an ltrace for command: "dd if=in.dat of=out.dat bs=4096 count=2500" with PID 12539 from PPID 12538
    if($line =~ m/Wrote an ltrace for command: \"(?<cmd>.*)\" with PID (?<pid>\d+) from PPID (?<ppid>\d+) on (?<host>\S+)$/) {
        $cmd = $+{cmd};
        $cmdpid = $+{pid};
        $cmdppid = $+{ppid};
        $host = $+{host};
        next;
    }
    #27851   0.000684 sh->fork()    = 27852
    elsif($line =~ m/(?<pid>\d+)\s+(?<access>\S+)\s+(?<call>\S+->fork)\(.*\)\s+=\s+(?<childpid>\S+)$/ or
        $line =~ m/(?<pid>\d+)\s+(?<access>\S+)\s+(?<call>\S+->clone)\(.*\)\s+=\s+(?<childpid>\S+)$/) {
        make_child($+{pid}, $+{access}, $+{call}, $+{childpid});
        next;
    }
    #16226   0.000550 fscheck->open("in.dat", 0, 00)  = 3
    elsif($line =~ m/(?<pid>\d+)\s+(?<access>\S+)\s+(?<call>\S+)(?<args>\(.*\))\s+=\s+(?<result>\S+)$/) {
        make_record($+{pid}, $+{access}, $+{call}, $+{result}, $+{args});
        next;
    } 
}

foreach my $process (keys(%processes)) {
    $processes{$process}{hash} = md5_hex($host, $cmdpid, $cmd, $process);
    my %r = %{$processes{$process}};
    print(STDOUT "INSERT OR REPLACE INTO process (hash, pid, ppid, host, log, system) VALUES ('$r{hash}', $r{pid}, $cmdpid, '$host', '$log', '$app');\n");
}

my @linktypes = ("component", "envVar", "file");
foreach my $linktype (@linktypes) {
    my @tabname = ("process", $linktype);
    @tabname = sort({ $a cmp $b } @tabname);
    my $table = "$tabname[0]_$tabname[1]";
    foreach my $process (keys(%processes)) {
        my $t1 = "process";
        my $hash = $processes{$process}{hash};
        my $t2 = "$linktype";
        my $pid = $processes{$process}{pid};
        my $insert;
        if($linktype eq "file") {
            my @files = uniq(split(',', $processes{$pid}{files}));
            foreach my $file (@files) {
                if(!$file) { next; }
                print(STDOUT "INSERT OR REPLACE INTO $table (process_hash, $linktype\_hash, host) SELECT $t1.hash AS process_hash, $t2.hash AS $linktype\_hash, $t1.host as host FROM $t1 JOIN $t2 ON $t1.log = $t2.log WHERE $t1\_hash = '$hash' AND $t2.path = $file AND $t2.system = '$app';\n");
            }
        }
        elsif($linktype eq "component") {
            print(STDOUT "INSERT OR REPLACE INTO $table (process_hash, $linktype\_hash, host) SELECT $t1.hash as process_hash, $t2.hash as $linktype\_hash, $t1.host as host FROM $t1 JOIN $t2 ON $t1.log = $t2.log WHERE $t1\_hash = '$hash' AND $t2.system = '$app';\n");
        }
        elsif($linktype eq "envVar") {
            my @envs = uniq(split(',', $processes{$pid}{envs}));
            foreach my $env (@envs) {
                if(!$env) { next; }
                print(STDOUT "INSERT OR REPLACE INTO $table (process_hash, $linktype\_hash, host) SELECT $t1.hash as process_hash, $t2.hash as $linktype\_hash, $t1.host as host FROM $t1 JOIN $t2 ON $t1.log = $t2.log WHERE $t1\_hash = '$hash' AND $t2.name = $env AND $t2.system = '$app';\n");
            }
        }
    }
}

sub make_child {
    my ($pid, $access, $call, $childpid) = @_;
    if(exists $processes{$pid}{children}) { $processes{$pid}{children} = $processes{$pid}{children} . ',' . $childpid; }
    else { $processes{$pid}{children} = $childpid; }
    $processes{$pid}{access} = $access;
    $processes{$pid}{call} = $call;
    return 0;
}

sub make_record {
    my ($pid, $access, $call, $result, $args) = @_;
    if($args and $call =~ m/\S*open\S*/ and $args =~ m/(?<file>\"\S+\")/) {
        if(exists $processes{$pid}{files}) { $processes{$pid}{files} = $processes{$pid}{files} . ',' . $+{file}; }
        else { $processes{$pid}{files} = $+{file}; }
    }
    elsif($args and $call =~ m/\S*env\S*/ and $args =~ m/(?<env>\"\S+\")/) {
        if(exists $processes{$pid}{envs}) { $processes{$pid}{envs} = $processes{$pid}{envs} . ',' . $+{env}; }
        else { $processes{$pid}{envs} = $+{env}; }
    }
    if(!exists $processes{$pid}{files}) { $processes{$pid}{files} = ""; }
    $processes{$pid}{pid} = $pid;
    $processes{$pid}{access} = $access;
    $processes{$pid}{call} = $call;
    $processes{$pid}{result} = $result;
    $processes{$pid}{system} = $app;
    return 0;
}

sub print_help {
    print $usage;
    exit(1);
}
# vim: tabstop=8 shiftwidth=4 softtabstop=4 expandtab shiftround autoindent
