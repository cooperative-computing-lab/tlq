#! /usr/bin/env perl

use 5.10.0;
use strict;
use Error qw(:try);
use Error::Simple;
use Getopt::Long qw(:config no_ignore_case);
use DateTime;
use JSON;

my $usage = "Makeflows Record Type Log Parser Options:

Required:
    <log>	    Sets the path to the log file.
    <app>           Sets the name of the origin application/system of the log.

Example Usage:
    makeflows-parser workflow.mflog testapp

";

if(@ARGV != 2) {
    print(STDERR $usage);
    exit 1;
}
my ($log, $app) = @ARGV;

my %master;
#Master has the following attributes:
#address
#start
#end
#failures
#workers
#rules
#tasks
#files

my $first = 1;
my $workerid = 1;
my $fileid = 1;
my $envid = 1;
my $procid = 1;
my $currtask = 1;
my $currrule = 0;
my $makeflow = 0;
my $prevline = 0;

open(LOG, $log);
while(my $line = <LOG>) {
    #wq: Master advertising as disc01.crc.nd.edu:9000
    if($line =~ m/wq: Master advertising as (?<master>[a-zA-Z0-9\-]+\.crc\.nd\.edu:\d+)/) {
        $master{address} = $+{master};
        $master{workers} = {};
        $master{rules} = {};
        $master{tasks} = {};
        $master{files} = {};
        $master{failures} = 0;
        next;
    }

    #makeflow: node 0 waiting -> running
    elsif($line =~ m/makeflow: node (?<ruleid>\d+) waiting -> running/) {
        $makeflow = 1;
        if(not exists $rules{$+{ruleid}}{ruleid}) {
            $rules{$+{ruleid}}{ruleid} = int($+{ruleid});
            $rules{$+{ruleid}}{master} = $master{address};
            $rules{$+{ruleid}}{workers} = {};
            $rules{$+{ruleid}}{tasks} = {};
            $rules{$+{ruleid}}{inputs} = {};
            $rules{$+{ruleid}}{outputs} = {};
            $rules{$+{ruleid}}{failures} = 0;
            $rules{$+{ruleid}}{retries} = 0;
        }
        $rules{$+{ruleid}}{state} = 2;
    }

    #batch: set option `task-id' to `1'
    elsif($line =~ m/batch: set option `task-id' to `(?<ruleid>\d+)'/) {
        if(not exists $rules{$+{ruleid}}{ruleid}) {
            $rules{$+{ruleid}}{ruleid} = int($+{ruleid});
            $rules{$+{ruleid}}{master} = $master{address};
            $rules{$+{ruleid}}{workers} = {};
            $rules{$+{ruleid}}{tasks} = {};
            $rules{$+{ruleid}}{inputs} = {};
            $rules{$+{ruleid}}{outputs} = {};
            $rules{$+{ruleid}}{failures} = 0;
            $rules{$+{ruleid}}{retries} = 0;
        }
        next;
    }
   
    #makeflow: node 0 running -> complete
    elsif($line =~ m/makeflow: node (?<ruleid>\d+) running -> complete/) {
        $rules{$+{ruleid}}{state} = 3;
        next;
    }

    #makeflow: node 0 running -> failed
    elsif($line =~ m/makeflow: node (?<ruleid>\d+) running -> failed/) {
        $rules{$+{ruleid}}{state} = 4;
        $rules{$+{ruleid}}{failures}++;
        $master{failures}++;
        next;
    }

    #makeflow: node 3 failed -> waiting
    elsif($line =~ m/makeflow: node (?<ruleid>\d+) failed -> waiting/) {
        $rules{$+{ruleid}}{retries}++;
        $rules{$+{ruleid}}{state} = 1;
        $tasks{$currtask}{rule}{ruleid} = int($+{ruleid}); 
        next;
    }

    #makeflow: Job 37 has returned.
    elsif($line =~ m/makeflow: Job (?<taskid>\d+) has returned/) {
        $currtask = $+{taskid};
        next;
    }

    #makeflow: File worker.35.debug created by rule 35.
    elsif($line =~ m/makeflow: File (?<file>\S+) created by rule (?<ruleid>\d+)/) {
        my $fid = -1;    
        if(not exists $files{$+{file}}{fileid}) {
            $fid = $fileid;
            $files{$+{file}}{fileid} = int($fid);
            $files{$+{file}}{name} = $+{file};
            $files{$+{file}}{accesses} = 1;
            $files{$+{file}}{processes} = {};
            $files{$+{file}}{workers} = {};
            $files{$+{file}}{master} = $master{address};
            $fileid++;
            $master{files}{$+{file}} = int($fid);
        }
        else {
            $fid = $files{$+{file}}{fileid};
        }
        if(not exists $files{$+{file}}{rules}{$+{ruleid}}) {
            $files{$+{file}}{rules}{$+{ruleid}} = int($+{ruleid});
        }
        $rules{$+{ruleid}}{outputs}{$+{file}} = int($fid);
        $tasks{$currtask}{rule}{ruleid} = int($+{ruleid});
        next;
    }
}
close(LOG);

sub print_help {
    print $usage;
    exit(1);
}
# vim: tabstop=8 shiftwidth=4 softtabstop=4 expandtab shiftround autoindent
