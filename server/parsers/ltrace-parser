#! /usr/bin/env perl

use strict;
use DateTime;
use Digest::MD5 qw(md5_hex);
use JSON;
use List::MoreUtils qw(uniq);
my $usage = "Log Parser for ltrace Options:

Required:
    <log>	    Sets the path to the log file.
    <app>           Sets the name of the origin application/system of the log.

Example Usage:
    ltrace-parser log.ltrace testapp

";

if(@ARGV != 2) {
    print(STDERR $usage);
    exit 1;
}
my ($log, $app) = @ARGV;
my %files = ();
my ($cmd, $host, $cmdpid, $cmdppid);
open(LOG, $log) or die "Could not open specified log file.\n";
while(my $line = <LOG>) {
    #Wrote an ltrace for command: "dd if=in.dat of=out.dat bs=4096 count=2500" with PID 12539 from PPID 12538
    if($line =~ m/Wrote an ltrace for command: \"(?<cmd>.*)\" with PID (?<pid>\d+) from PPID (?<ppid>\d+) on (?<host>\S+)$/) {
        $cmd = $+{cmd};
        $cmdpid = $+{pid};
        $cmdppid = $+{ppid};
        $host = $+{host};
        next;
    }
    #16226   0.000550 fscheck->open("in.dat", 0, 00)  = 3
    elsif($line =~ m/(?<pid>\d+)\s+(?<access>\S+)\s+(?<prog>\S+)->open\d*\(\"(?<file>\S+)\", \d+, \d+\)\s+=\s+(?<result>\S+)$/) {
        my $failure = 0;
        if($+{result} == -1) { $failure = 1; }
        make_record($+{pid}, $+{access}, $+{prog}, $+{file}, $+{result}, $failure);
        next;
    }
    #3111   0.000672 libpython2.7.so.1.0->fopen64("test.txt", "a+")  = 0x8b22a0
    elsif($line =~ m/(?<pid>\d+)\s+(?<access>\S+)\s+(?<prog>\S+)->fopen\d*\(\"(?<file>\S+)\", \S+\)\s+=\s+(?<result>\S+)$/) {
        my $failure = 0;
        if($+{result} == 0) { $failure = 1; }
        make_record($+{pid}, $+{access}, $+{prog}, $+{file}, $+{result}, $failure);
        next;
    }
    #12396   0.000368 fscheck->__xstat(1, "/disk/", 0x7ffd931d20d0) = 0
    elsif($line =~ m/(?<pid>\d+)\s+(?<access>\S+)\s+(?<prog>\S+)->__xstat\(\d+, \"(?<file>\S+)\", \S+\)\s+=\s+(?<result>\S+)$/) {
        my $failure = 0;
        if($+{result} == -1) { $failure = 1; }
        make_record($+{pid}, $+{access}, $+{prog}, $+{file}, $+{result}, $failure);
        next;
    }
}

foreach my $file (keys(%files)) {
    $files{$file}{hash} = md5_hex($host, $files{$file}{pids}, $file);
    my %r = %{$files{$file}};
    print(STDOUT "INSERT OR REPLACE INTO file (hash, path, failures, host, log, system) VALUES ('$r{hash}', '$r{path}', $r{failures}, '$host', '$log', '$app');\n");
}

my @linktypes = ("process");
foreach my $linktype (@linktypes) {
    my @tabname = ("file", $linktype);
    @tabname = sort({ $a cmp $b } @tabname);
    my $table = "$tabname[0]_$tabname[1]";
    foreach my $file (keys(%files)) {
        my $t1 = "file";
        my $hash = $files{$file}{hash};
        my $t2 = "$linktype";
        my $insert;
        if($linktype eq "process") {
            my @pids = uniq(split(',', $files{$file}{pids}));
            foreach my $pid (@pids) {
                print(STDOUT "INSERT OR REPLACE INTO $table (file_hash, $linktype\_hash, host) SELECT $t1.hash AS file_hash, $t2.hash AS $linktype\_hash, $t1.host FROM $t1 JOIN $t2 ON $t1.log = $t2.log WHERE $t1.hash = '$hash' AND $t2.pid = $pid AND $t2.system = '$app';\n");
            }
        }
    }
}

sub make_record {
    my ($pid, $access, $prog, $file, $result, $failure) = @_;
    if(exists $files{$file}{pids}) { $files{$file}{pids} = $files{$file}{pids} . ',' . $pid; }
    else { $files{$file}{pids} = $pid; }
    if(exists $files{$file}{failures} and $failure) { $files{$file}{failures}++; }
    elsif($failure) { $files{$file}{failures} = $failure; }
    else { $files{$file}{failures} = 0; }
    $files{$file}{access} = $access;
    $files{$file}{prog} = $prog;
    $files{$file}{path} = $file;
    $files{$file}{result} = $result;
    $files{$file}{system} = $app;
    return 0;
}

sub print_help {
    print $usage;
    exit(1);
}
# vim: tabstop=8 shiftwidth=4 softtabstop=4 expandtab shiftround autoindent
