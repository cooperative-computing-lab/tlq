#! /usr/bin/env perl

use 5.10.0;
use strict;
use Error qw(:try);
use Error::Simple;
use Getopt::Long qw(:config no_ignore_case);
use DateTime;
use JSON;

my $usage = "Work Queue Workers Record Type Log Parser Options:

Required:
    <log>	    Sets the path to the log file.
    <app>           Sets the name of the origin application/system of the log.

Example Usage:
    work-queue-workers-parser worker.wqlog testapp

";

if(@ARGV != 2) {
    print(STDERR $usage);
    exit 1;
}
my ($log, $app) = @ARGV;

my %workers;
#Worker has the following attributes:
#workerid
#address
#bandwidth
#start
#end
#failures
#master
#rules
#tasks
#files

my $first = 1;
my $workerid = 1;
my $fileid = 1;
my $envid = 1;
my $procid = 1;
my $currtask = 1;
my $currrule = 0;
my $makeflow = 0;
my $prevline = 0;

open(LOG, $log);
while(my $line = <LOG>) {
    #wq: connected to master 10.32.74.140:9000 via local address 10.32.74.164:36500
    if($line =~ m/wq: connected to master \S+ via local address \S+:(?<port>\d+)/) {
        $port = $+{port};
        next;
    }

    #dns: finding my hostname: uname = disc13.crc.nd.edu, address = 10.32.74.164, hostname = disc13.crc.nd.edu
    elsif($line =~ m/dns: finding my hostname: uname = \S+, address = \S+, hostname = (?<addr>\S+)/) {
        $addr = $+{addr};
        $currworker = "$addr:$port";
        next;
    }

    #wq: rx from master: task 10
    elsif($line =~ m/wq: rx from master: task (?<taskid>\d+)/ and $currworker) {
        $currtask = $+{taskid};
        next;
    }

    #wq: task 82 (pid 1110) exited normally with exit code 1
    elsif($line =~ m/wq task (?<taskid>\d+) \(pid \d+\) exited \S+normally with exit code (?<status>\S+)/) {
        $tasks{$+{taskid}}{exit} = int($+{status});
        if(exists $tasks{$currtask}{rule}{ruleid}) {
            my $rule = $tasks{$currtask}{rule}{ruleid};
            $rules{$rule}{exit} = int($+{status});
        }
        next;
    }

    
    #wq: could not rename output file /var/condor/execute/dir_20022/worker-213124-20026/t.2/out.dat to cache/file-10-7a6fc525356ac795b582a230c9e31976-out.2.dat: No such file or directory
    elsif($line =~ m/wq: could not rename output file/) {
        $tasks{$currtask}{failures}++;
        next;
    }

    #wq: started process 23264: ./ltrace-wrapper ./fscheck runtime.config && sleep 1
    elsif($line =~ m/wq: started process (?<pid>\d+): (?<command>[^\n]+)/ and $currworker) {
        $tasks{$currtask}{pid} = int($+{pid});
        $tasks{$currtask}{command} = $+{command};
        if(exists $tasks{$currtask}{rule}{ruleid}) {
            my $rule = $tasks{$currtask}{rule}{ruleid};
            my $workerid = $workers{$currworker}{workerid};
            $rules{$rule}{tasks}{$currtask} = int($currtask);
            $rules{$rule}{workers}{$workerid} = int($workerid);
            $rules{$rule}{category} = $tasks{$currtask}{category};
            $rules{$rule}{cores} = $tasks{$currtask}{cores};
            $rules{$rule}{gpus} = $tasks{$currtask}{gpus};
            $rules{$rule}{memory} = $tasks{$currtask}{memory};
            $rules{$rule}{disk} = $tasks{$currtask}{disk};
            foreach my $f (keys($tasks{$currtask}{inputs})) {
                $rules{$rule}{inputs}{$f} = int($files{$f}{fileid});
                if(not exists $files{$f}{rules}{$rule}) {
                    $files{$f}{rules}{$rule} = int($rule);
                }
            }
            foreach my $f (keys($tasks{$currtask}{outputs})) {
                $rules{$rule}{outputs}{$f} = int($files{$f}{fileid});
                if(not exists $files{$f}{rules}{$rule}) {
                    $files{$f}{rules}{$rule} = int($rule);
                }
            }
            if(not exists $workers{$currworker}{rules}{$rule}) { $workers{$currworker}{rules}{$rule} = int($rule); }
            if(not exists $master{rules}{$rule}) { $master{rules}{$rule} = int($rule); }
        }
        next;
    }

}
close(LOG);

exit(0);

sub print_help {
    print $usage;
    exit(1);
}
# vim: tabstop=8 shiftwidth=4 softtabstop=4 expandtab shiftround autoindent
