#! /usr/bin/env perl

use 5.10.0;
use strict;
use Error qw(:try);
use Error::Simple;
use Getopt::Long qw(:config no_ignore_case);
use DateTime;
use JSON;

my $usage = "Makeflow Rules Record Type Log Parser Options:

Required:
    <log>	    Sets the path to the log file.
    <app>           Sets the name of the origin application/system of the log.

Example Usage:
    makeflows-parser workflow.mflog testapp

";

if(@ARGV != 2) {
    print(STDERR $usage);
    exit 1;
}
my ($log, $app) = @ARGV;

my %rules;
#Rule has the following attributes:
#ruleid
#jobid
#state
#failures
#retries
#category
#cores
#gpus
#memory
#disk
#command
#
#makeflow
#master
#workers
#tasks
#inputs
#outputs
#files

open(LOG, $log);
while(my $line = <LOG>) {

    #makeflow: node 0 waiting -> running
    if($line =~ m/makeflow: node (?<ruleid>\d+) waiting -> running/) {
        $makeflow = 1;
        if(not exists $rules{$+{ruleid}}{ruleid}) {
            $rules{$+{ruleid}}{ruleid} = int($+{ruleid});
            $rules{$+{ruleid}}{master} = $master{address};
            $rules{$+{ruleid}}{workers} = {};
            $rules{$+{ruleid}}{tasks} = {};
            $rules{$+{ruleid}}{inputs} = {};
            $rules{$+{ruleid}}{outputs} = {};
            $rules{$+{ruleid}}{failures} = 0;
            $rules{$+{ruleid}}{retries} = 0;
        }
        $rules{$+{ruleid}}{state} = 2;
    }

    #makeflow: node 0 running -> complete
    elsif($line =~ m/makeflow: node (?<ruleid>\d+) running -> complete/) {
        $rules{$+{ruleid}}{state} = 3;
        next;
    }

    #makeflow: node 0 running -> failed
    elsif($line =~ m/makeflow: node (?<ruleid>\d+) running -> failed/) {
        $rules{$+{ruleid}}{state} = 4;
        $rules{$+{ruleid}}{failures}++;
        $master{failures}++;
        next;
    }

    #makeflow: node 3 failed -> waiting
    elsif($line =~ m/makeflow: node (?<ruleid>\d+) failed -> waiting/) {
        $rules{$+{ruleid}}{retries}++;
        $rules{$+{ruleid}}{state} = 1;
        $tasks{$currtask}{rule}{ruleid} = int($+{ruleid}); 
        next;
    }

    #makeflow: Job 37 has returned.
    elsif($line =~ m/makeflow: Job (?<taskid>\d+) has returned/) {
        $currtask = $+{taskid};
        next;
    }

    #makeflow: File worker.35.debug created by rule 35.
    elsif($line =~ m/makeflow: File (?<file>\S+) created by rule (?<ruleid>\d+)/) {
        my $fid = -1;    
        if(not exists $files{$+{file}}{fileid}) {
            $fid = $fileid;
            $files{$+{file}}{fileid} = int($fid);
            $files{$+{file}}{name} = $+{file};
            $files{$+{file}}{accesses} = 1;
            $files{$+{file}}{processes} = {};
            $files{$+{file}}{workers} = {};
            $files{$+{file}}{master} = $master{address};
            $fileid++;
            $master{files}{$+{file}} = int($fid);
        }
        else {
            $fid = $files{$+{file}}{fileid};
        }
        if(not exists $files{$+{file}}{rules}{$+{ruleid}}) {
            $files{$+{file}}{rules}{$+{ruleid}} = int($+{ruleid});
        }
        $rules{$+{ruleid}}{outputs}{$+{file}} = int($fid);
        $tasks{$currtask}{rule}{ruleid} = int($+{ruleid});
        next;
    }
}
close(LOG);

sub print_help {
    print $usage;
    exit(1);
}
# vim: tabstop=8 shiftwidth=4 softtabstop=4 expandtab shiftround autoindent
