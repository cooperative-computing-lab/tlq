#! /usr/bin/env perl

use Error qw(:try);
use Error::Simple;
use Getopt::Long qw(:config no_ignore_case);
use sigtrap qw/handler signal_handler INT TERM/;
use Sys::Hostname;

use strict;

my $usage = "TLQ Log Server Options:

Required:

Optional:
    --dir,-d    <path>      Use the specified path for TLQ's working directory.
                            Default: /tmp/tlq
    --port,-p   <integer>   Attempt to use selected port.
                            Default: 9000.

    --help                  Display this message.

Example Usage:

    perl tlq_server --port 9000 --dir /tmp/user/tlq

";

my %OPT;
try {
    GetOptions(
        "dir=s" => \$OPT{dir},
        "port=s" => \$OPT{port},
        "help|?" => sub { print $usage; exit(0); },
    );
}
catch Error::Simple with {
    my $E = shift;
    print STDERR $E->{-text};
    die "Failed to parse command line options.\n";
};

my $client = 0;
my $err = 0;
our $dir = $OPT{dir};
my $port = $OPT{port};
if(!$dir) { $dir = "/tmp/tlq"; }
if(!$port) { $port = 9000; }
if($err) { print_help(); }
my $host = hostname();
my $start = time();

#Define application-specific web server handling
{
    package WebServer;
    use Compress::Zlib;
    use Data::Dumper;
    use HTTP::Server::Simple::CGI;
    use IO::Socket::INET;
    use JSON;
    use Sys::Hostname;
    use threads;
    use URI::Encode;
    use base qw(HTTP::Server::Simple::CGI);

    my %logs; #Logs have a UUID, path, JSON path, type, component, and size
    my %parsers; #Parsers have an type ID, and path
    if(!(-e $dir)) { mkdir($dir); }
    else { check_deposit(); }
    chmod(0766, $dir);
    opendir(DIR, "parsers");
    my @localparsers = grep(/_parser$/,readdir(DIR));
    closedir(DIR);
    foreach my $p (@localparsers) {
        system("cp parsers/$p $dir/$p");
        my $type = $p;
        $type =~ s/_parser//g;
        $parsers{$type} = {};
        $parsers{$type}{path} = "$dir/$p";
    }
    my $host = hostname();
    my $log_thread = threads->create("watch_logs");
    $log_thread->detach();
    my %dispatch = (
        "/query" => \&run_query,
        "/jx" => \&send_json,
        "/pull" => \&send_file,
        "/rm" => \&rm_file
    );

    sub check_deposit {
        open(DEPOSIT, "$dir/deposits.log");
        while(my $line = <DEPOSIT>) {
            chomp($line);
            my @parts = split(' ', $line);
            my ($log, $home, $redirect, $type, $uuid) = @parts;
            my $cmd = join(' ', @parts[5..$#parts]);
            if(exists($logs{$uuid})) { next; }
            $logs{$uuid} = {};
            $logs{$uuid}{json} = "$dir/$uuid.json";
            $logs{$uuid}{original} = $log;
            $logs{$uuid}{home} = $home;
            $logs{$uuid}{path} = $redirect;
            $logs{$uuid}{size} = 0;
            $logs{$uuid}{logtype} = $type;
            $logs{$uuid}{type} = "tlq_log";
            $logs{$uuid}{command} = $cmd;
            $logs{$uuid}{noredirect} = 0;
            $logs{$uuid}{parsed} = 0;
            $logs{$uuid}{name} = $host;
            $logs{$uuid}{port} = $port;
            if(-e $logs{$uuid}{json}) { $logs{$uuid}{parsed} = 1; }
            if($redirect eq "NONE") {
                $logs{$uuid}{path} = "$dir/$uuid.log";
                $logs{$uuid}{noredirect} = 1;
            }
            my $uri="http://$host:$port/<ACTION>/$uuid";
            my $deposit = "$cmd created log $log queryable at $uri.";
            system("curl -s --data-urlencode \"DEPOSIT=$deposit\" http://$home/deposit");
        }
        close(DEPOSIT);
    }

    sub check_file {
        my ($file, $mode) = @_;
        if(!$file) { return 0; }
        if(exists($logs{$file}) and !$mode) { $file = $logs{$file}{path}; }
        elsif(exists($logs{$file}) and $mode) { $file = $logs{$file}{json}; }
        if(!(-e $file)) { return 0; }
        my $result = open(FILE, $file);
        close(FILE);
        if(!$result) { return 0; }
        return $file;
    } 

    sub run_query {
        my ($cgi) = @_;
        my $query = request_from_json($cgi->param("PUTDATA"));
        my $data = "";
        my %encode;
        $encode{query} = $query;
        $encode{result} = `$query`;
        my $result = JSON->new->utf8->encode(\%encode);
        print(STDOUT "$result");
        return 0;
    }

    sub send_json {
        my ($cgi) = @_;
        my ($uuid, $json);
        if($cgi->path_info() =~ m/jx\/(?<uuid>[a-f0-9\-]+)(.json)?/) { $uuid = $+{uuid}; }
        $json = "$uuid.json";
        $json = check_file($uuid, 1);
        return transfer($cgi, $json);
    }

    sub send_file {
        my ($cgi) = @_;
        my $file = request_from_json($cgi->param("PUTDATA"));
        $file = check_file($file, 0);
        return transfer($cgi, $file);
    }

    sub rm_file {
        my ($cgi) = @_;
        my ($uuid, $err, $flag, $result) = 0;
        my %encode;
        if($cgi->path_info() =~ m/rm\/(?<uuid>[a-f0-9\-]+)(.json)?/ or $cgi->path_info() =~ m/rm\/(?<uuid>[a-f0-9\-]+)(.log)?/) { $uuid = $+{uuid}; }
        if($uuid) {
            my $file = check_file($uuid, 1);
            if($file) { $result = unlink($file); }
            if(!$result) {
                $err = $!;
                $flag = 1;
            }
            $encode{json} = $file;
            $encode{error} = $err;
            $file = check_file($uuid, 0);
            if($file) { unlink($file); }
            if(!$result) {
                $err = $!;
                $flag = 1;
            }
            $encode{log} = $file;
            $encode{error} = $err;
            if(!$flag) { delete($logs{$uuid}); }
        }
        if($flag) {
            $encode{result} = "failure";
            my $json = JSON->new->utf8->encode(\%encode);
            print(STDOUT "$json");
            return 1;
        }
        else {
            $encode{result} = "success";
            my $json = JSON->new->utf8->encode(\%encode);
            print(STDOUT "$json");
            return 0;
        }
    }

    sub transfer {
        my ($cgi, $file) = @_;
        if(!$file) {
            my %encode;
            $encode{result} = "failure";
            $encode{error} = "$file not found";
            my $json = JSON->new->utf8->encode(\%encode);
            print(STDOUT "$json");
            return 1;
        }
        my $rawtext = "";
        open(FILE, $file);
        while(my $line = <FILE>) { $rawtext = $rawtext . $line; }
        close(FILE);
        print(STDOUT "$rawtext");
        return 0;
    }

    sub parse_logs {
        my ($type) = @_;
        my $parser = $parsers{$type}{path};
        my @toparse;
        foreach my $uuid (keys(%logs)) {
            if((!$logs{$uuid}{parsed} and $logs{$uuid}{logtype} eq $type) or ($logs{$uuid}{logtype} eq $type and ($logs{$uuid}{size} < -s $logs{$uuid}{path}))) { push(@toparse, $uuid); }
            $logs{$uuid}{size} = -s $logs{$uuid}{path};
        }
        foreach my $uuid (@toparse) {
            my $path = $logs{$uuid}{path};
            print(STDERR "Calling $parser $path $uuid\n");
            my $parsed = `$parser $path $uuid`;
            my $json = $logs{$uuid}{json};
            if(-e $json) { unlink($json); }
            open(QUERIES, ">>", $json);
            print(QUERIES $parsed);
            close(QUERIES);
            $logs{$uuid}{parsed} = 1;
        }
        return 0;
    }

    sub watch_logs {
        my $flag = 1;
        my @prevlogs;
        while($flag) {
            check_deposit();
            foreach my $uuid (keys(%logs)) {
                if($logs{$uuid}{noredirect} and -e $logs{$uuid}{original} and $logs{$uuid}{size} < -s $logs{$uuid}{original}) {
                    system("cp $logs{$uuid}{original} $logs{$uuid}{path}");
                }
            }
            foreach my $type (keys(%parsers)) { parse_logs($type); }
            my @listlogs;
            foreach my $l (sort(keys(%logs))) {
                my %item;
                $item{uuid} = $l;
                $item{url} = "http://$host:$port/jx/$l.json";
                $item{type} = $logs{$l}{logtype};
                $item{command} = $logs{$l}{command};
                $item{home} = $logs{$l}{home};
                $item{path} = $logs{$l}{path};
                $item{original} = $logs{$l}{original};
                push(@listlogs, \%item);
            }
            if(scalar(@listlogs) != scalar(@prevlogs)) {
                my %encode;
                $encode{type} = "tlq_server";
                $encode{name} = $host;
                $encode{port} = $port;
                $encode{owner} = $ENV{USER};
                $encode{working_dir} = $dir;
                $encode{starttime} = $start;
                $encode{url} = "http://$host:$port";
                $encode{logs} = \@listlogs;
                print(STDERR "Sending heartbeat to catalog.cse.nd.edu:9097.\n");
                my $heartbeat = JSON->new->utf8->encode(\%encode);
                $heartbeat = Compress::Zlib::compress($heartbeat);
                my $socket = IO::Socket::INET->new(PeerAddr => "catalog.cse.nd.edu:9097", Proto => "udp");
                $socket->send(chr(26) . $heartbeat);
                $socket->close();
                @prevlogs = @listlogs;
            }
            sleep(1);
        }
        print(STDERR "\nExiting log watcher thread.\n");
        threads->exit();
        return 0;
    }

    sub request_from_json {
        my ($json) = @_;
        $json = URI::Encode->new( { encode_reserved => 0 } )->decode($json);
        my $queryref = JSON->new->decode($json);
        my %query = %$queryref;
        my $dump = Dumper(%query);
        return $query{query};
    }

    sub handle_request {
        my ($self, $cgi) = @_;
        my $path = $cgi->path_info();
        if($path =~ m/jx/) { $path = "/jx"; }
        elsif($path =~ m/query/) { $path = "/query"; }
        elsif($path =~ m/rm/) { $path = "/rm"; }
        my $handler = $dispatch{$path};
        check_deposit();
        if(ref($handler) eq "CODE") { $handler->($cgi); }
        else {
            my %encode;
            $encode{result} = "failure";
            $encode{error} = "404 Not found";
            my $json = JSON->new->utf8->encode(\%encode);
            print(STDOUT "$json");
        }
        return 0;
    }
}

my $server = WebServer->new($port);
print(STDOUT "Server established at $host:$port.\n\n");
$server->run();
exit(0);

sub signal_handler {
    print(STDERR "\nCaught '$!' signal. Terminating process.\n");
    exit(1);
}

sub print_help {
    print(STDOUT $usage);
    exit(1);
}

# vim: tabstop=8 shiftwidth=4 softtabstop=4 expandtab shiftround autoindent
