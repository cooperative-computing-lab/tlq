#! /usr/bin/env perl

use Error qw(:try);
use Error::Simple;
use Getopt::Long qw(:config no_ignore_case);
use IO::Socket::PortState qw(check_ports);
use sigtrap qw/handler signal_handler INT TERM/;
use Sys::Hostname;

use strict;

#Define application-specific web server handling
{
    package WebServer;
    use Data::Dumper;
    use DBD::SQLite;
    use DBD::Pg;
    use DBI;
    use File::Basename;
    use HTTP::Server::Simple::CGI;
    use JSON;
    use Sys::Hostname;
    use threads;
    use Thread::Semaphore;
    use URI::Encode;
    use base qw(HTTP::Server::Simple::CGI);

    my $database = "dbi:SQLite:dbname=:memory:";
    my $db = DBI->connect($database);
    my $dir = "/tmp/logquery";
    if(!(-e $dir)) { mkdir($dir); }
    else {
        unlink("$dir/lookup-log");
        unlink("$dir/deposit-queries");
        unlink("$dir/deposit-parser");
    }
    chmod(0766, $dir);
    opendir(DIR, "parsers");
    my @localparsers = grep(/-parser$/,readdir(DIR));
    closedir(DIR);
    open(DEPOSIT, ">>", "$dir/deposit-parser");
    foreach my $p (@localparsers) {
        system("cp parsers/$p $dir/$p");
        my @parseparts = split('-', $p);
        my $type = $parseparts[0];
        print(DEPOSIT "$dir/$p $type perl\n");
    }
    close(DEPOSIT);
    my $sem = Thread::Semaphore->new();
    my $host = hostname();
    my $log_thread = threads->create("watch_logs");
    $log_thread->detach();
    my %dispatch = (
        "/backup" => \&backup_db,
        "/components" => \&component_query,
        "/exit" => \&cleanup,
        "/files" => \&send_file,
        "/query" => \&execute_query
    );
    my %components;
    my %logs;
    my %parsers;
    my %tables;

    sub add_table {
        my ($cmd) = @_;
        if($cmd =~ m/CREATE TABLE\s?(IF NOT EXISTS)? (?<table>\S+) \((?<columns>[^\)]+)\);/) {
            my $table = $+{table};
            $tables{$table} = 1;
        }
        return 0;
    }

    sub backup_db {
        my ($cgi) = @_;
        my $backup = $cgi->url_param("file");
        $db->sqlite_backup_to_file($backup);
        return send_file($cgi);
    }

    sub check_deposit {
        my ($printmode) = @_;
        open(DEPOSIT, "$dir/deposit-log");
        while(my $line = <DEPOSIT>) {
            chomp($line);
            my @parts = split(' ', $line);
            my ($sys, $component, $log, $type, $hash) = @parts;
            if(exists($logs{$hash})) { next; }
            $logs{$hash} = {};
            $logs{$hash}{suuid} = $sys;
            $logs{$hash}{path} = $log;
            $logs{$hash}{type} = $type;
            $logs{$hash}{cuuid} = $component;
            if(!exists $components{$component}) {
                $components{$component} = {};
                $components{$component}{files} = $hash;
            }
            else { $components{$component}{files} = $components{$component}{files} . " $hash"; }
            if($printmode) { submit_lookup($sys, $log, $type, $hash); }
        }
        close(DEPOSIT);
    }

    sub check_file {
        my ($file) = @_;
        if(!$file) { return 1; }
        if(exists($logs{$file})) { $file = $logs{$file}{path}; }
        my $result;
        if(!(-e $file)) { return 1; }
        $result = open(FILE, $file);
        close(FILE);
        if(!$result) { return 1; }
        return 0;
    } 

    sub check_parsers {
        open(DEPOSIT, "$dir/deposit-parser");
        while(my $line = <DEPOSIT>) {
            chomp($line);
            my @parts = split(' ', $line);
            my ($path, $type, $interpreter) = @parts;
            if(exists($parsers{$type})) { next; }
            $parsers{$type} = {};
            $parsers{$type}{path} = $path;
            $parsers{$type}{interpreter} = $interpreter;
        }
        close(DEPOSIT);
    }

    sub cleanup {
        my ($cgi) = @_;
        print(STDOUT "HTTP/1.0 200 OK\n");
        print(STDOUT $cgi->header);
        print(STDOUT $cgi->start_html("Shutdown request"));
        print(STDOUT $cgi->h1("Received shutdown request"));
        print(STDOUT $cgi->end_html);
        unlink("$dir/deposit-parser");
        unlink("$dir/deposit-queries");
        kill(-15, $$);
        kill(-15, getppid());
        exit 0;
    }

    sub component_get_files {
        my ($component) = @_;
        my @array = split($components{$component}{files}, ' ');
        return @array;
    }

    sub component_query {
        my ($cgi) = @_;
        my $component;
        my $file;
        if($cgi->path_info() =~ m/components\/(?<uri>\S+)(\/(?<file>\S+))?/) {
            $component = $+{uri};
            $file = $+{file};
        }
        else { return 1; }
        my @files;
        if(!$file) { @files = component_get_files($component); }
        else { push(@files, $file); }
        my $query = query_from_json($cgi->param("PUTDATA"));
        #TODO Query execution
        #my $json = execute_query($query);
        my $json = "TEST";
        print(STDOUT "HTTP/1.0 200 OK\n");
        print(STDOUT $cgi->header);
        print(STDOUT $cgi->start_html("Record(s) retrieved."));
        print(STDOUT "$json from query $query");
        print(STDOUT $cgi->end_html);
        return 0;
    }

    sub send_file {
        my ($cgi) = @_;
        my $file = $cgi->url_param("file");
        if(check_file($file)) {
            print(STDOUT "HTTP/1.0 500 Internal server error\n");
            print(STDOUT $cgi->header);
            print(STDOUT $cgi->start_html("File not found.."));
            print(STDOUT $cgi->h1("File '$file' not found"));
            print(STDOUT $cgi->end_html);
            return 1;
        }
        if(exists($logs{$file})) { $file = $logs{$file}{path}; }
        my $rawtext = "";
        open(FILE, $file);
        while(my $line = <FILE>) { $rawtext = $rawtext . $line; }
        close(FILE);
        print(STDOUT "HTTP/1.0 200 OK\n");
        print(STDOUT $cgi->header);
        print(STDOUT $cgi->start_html("Log sent"));
        print(STDOUT $cgi->h1("Dumping raw contents of '$file' to STDOUT"));
        print(STDOUT "\n$rawtext");
        print(STDOUT $cgi->end_html);
        return 0;
    }

    sub parse_type {
        my ($type) = @_;
        my $parser = $parsers{$type}{path};
        my $interpreter = $parsers{$type}{interpreter};
        my @toparse;
        foreach my $log (keys(%logs)) { if($logs{$log}{types} =~ m/$type/ and ($logs{$log}{size} < -s $logs{$log}{path})) { push(@toparse, $logs{$log}{path}); } }
        foreach my $log (@toparse) {
            my $parsed = parse_file($log, $parser, $interpreter);
            my $queryfile = "$dir/deposit-queries";
            while(!$$sem) { sleep(1); }
            open(QUERIES, ">>", $queryfile);
            print(QUERIES $parsed);
            close(QUERIES);
        }
        return 0;
    }

    sub parse_file {
        my ($file, $parser, $interpreter) = @_;
        my $parsed = "";
        foreach my $log (keys(%logs)) {
            if($logs{$log}{path} eq $file) {
                my $f = $logs{$log}{path};
                my $sys = $logs{$log}{sys};
                $parsed = `$interpreter $parser $f $sys`;
            }
        }
        return $parsed;
    }

    sub update_db {
        my $queryfile = "$dir/deposit-queries";
        $sem->down();
        my @outstanding;
        open(QUERIES, $queryfile);
        while(my $line = <QUERIES>) { chomp($line); push(@outstanding, $line); }
        close(QUERIES);
        foreach my $query (@outstanding) {
            add_table($query);
            my $dbcall = $db->prepare($query);
            $dbcall->execute;
        }
        unlink($queryfile);
        $sem->up();
    }

    #TODO Match field names to retrieved values
    sub execute_query {
        my ($query) = @_;
        my $mode = 0;
        my $result = "";
        print(STDERR "Got query: $query\n");
        my @contents = split(' ', $query);
        if($contents[0] eq "INSERT" or $contents[0] eq "UPDATE" or $contents[0] eq "CREATE") { $mode = 1; }
        if($query =~ m/CREATE TABLE/) { add_table($query); }
        my $dbcall;
        if($mode) { $dbcall = $db->do($query); }
        else { 
            $dbcall = $db->prepare($query);
            $dbcall->execute;
            my @fieldnames = @{ $dbcall->{NAME} };
            my $fields = join(" TEXT, ", @fieldnames);
            $fields = $fields . " TEXT";
            my $insfields = join(", ", @fieldnames);
            $result = $result . "CREATE TABLE IF NOT EXISTS result (ID INTEGER PRIMARY KEY AUTOINCREMENT, $fields);\n";
            while(my @row = $dbcall->fetchrow_array) {
                my $r = join(', ', map { "'$_'" } @row);
                $result = $result . "INSERT OR REPLACE INTO result ($insfields) VALUES ($r);\n";
            }
            chomp($result);
        }
        my %response;
        $response{result} = $result;
        my $json = JSON->new->encode(\%response);
        $json = URI::Encode->new( { encode_reserved => 0 } )->encode($json);
        return $json;
    }

    sub watch_logs {
        my $flag = 1;
        check_parsers();
        while($flag) {
            check_deposit(1);
            foreach my $type (keys(%parsers)) { parse_type($type); }
            foreach my $log (keys(%logs)) { $logs{$log}{size} = -s $logs{$log}{path}; }
            sleep(10);
        }
        print(STDERR "\nExiting log watcher thread.\n");
        threads->exit();
        return 0;
    }

    sub query_from_json {
        my ($json) = @_;
        $json = URI::Encode->new( { encode_reserved => 0 } )->decode($json);
        my $queryref = JSON->new->decode($json);
        my %query = %$queryref;
        my $dump = Dumper(%query);
        return $query{query};
    }

    sub submit_lookup {
        my ($sys, $log, $types, $hash) = @_;
        open(LOOKUP, ">>", "$dir/lookup-log");
        print(LOOKUP "$sys $log $types $hash\n");
        close(LOOKUP);
        return 0;
    }

    sub handle_request {
        my ($self, $cgi) = @_;
        my $path = $cgi->path_info();
        if($path =~ m/components/) { $path = "/components"; }
        my $handler = $dispatch{$path};
        check_deposit(0);
        check_parsers();
        update_db();
        if(ref($handler) eq "CODE") { $handler->($cgi); }
        else {
            print(STDOUT "HTTP/1.0 404 Not found\n");
            print(STDOUT $cgi->header);
            print(STDOUT $cgi->start_html("Not found"));
            print(STDOUT $cgi->h1("Not found"));
            print(STDOUT $cgi->end_html);
        }
        return 0;
    }
}

my $usage = "Debug Log Querying Server Options:

Required:

Optional:
    --port,-p   <integer>   Attempt to use selected port when server mode is used.
                            If attempt fails, the next available port will be used.
                            Default: 9000.

    --help                  Display this message.

Example Usage:

    perl server --port 9000

";

my %OPT;
try {
    GetOptions(
        "port=s" => \$OPT{port},
        "help|?" => sub { print $usage; exit(0); },
    );
}
catch Error::Simple with {
    my $E = shift;
    print STDERR $E->{-text};
    die "Failed to parse command line options.\n";
};

my $client = 0;
my $err = 0;
my $port = $OPT{port};
if(!$port) { $port = 9000; }
if($err) { print_help(); }

my %ports = ("tcp" => {});
my $timeout = 1;
my $start = $port;
my $end = $port + 500;
while($start < $end) {
    $ports{tcp}{$start} = {};
    $start++;
}
my $checked = check_ports("localhost", $timeout, \%ports);
my $valid = 0;
if($checked->{tcp}{$port}{open} == 1) {
    for my $p (sort(keys(%{$checked->{tcp}}))) {
        if($checked->{tcp}{$p}{open} == 0) {
            $port = $p;
            $valid = 1;
            last;
        }
    }
}
else { $valid = 1; }
if(!$valid) { print(STDERR "No available port found in range $port to $end. Terminating server.\n"); }
my $host = hostname();
my $server = WebServer->new($port);
print(STDOUT "Server established at $host:$port.\n\n");
$server->run();
exit(0);

sub signal_handler {
    print(STDERR "\nCaught '$!' signal. Terminating process.\n");
    exit(1);
}

sub print_help {
    print(STDOUT $usage);
    exit(1);
}

# vim: tabstop=8 shiftwidth=4 softtabstop=4 expandtab shiftround autoindent
